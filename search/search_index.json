{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the Kunoichi documentation portal!</p> <p>Arc Plugins are a collection of plugins published by Puny Human on the Unreal Marketplace.  They are designed for multiplayer games across many genres, and built to empower developers to create amazing games without having to rewrite all the boilerplate for common systems.  They are all highly performant, shipping in multiple titles, and multiplayer focused.  </p>"},{"location":"#the-plugins","title":"The Plugins","text":"<ul> <li> Arc Inventory <p>Quote</p> Arc Inventory is a Gameplay Ability System based inventory solution that allows for the creation of ability-powered items and inventory management, and can slot seamlessly into your GAS-based game. Arc Inventory is built from the ground up for multiplayer, and supports everything from passive items, active items, stacking items, and more. Using Arc Inventory, you can create shooter gameplay, RPG gameplay, and even procedurally generate items or create an attachment system. <p>Unreal Marketplace \u2022 Documentation</p> </li> <li> Arc Teams <p>Quote</p> Arc Teams is a networked multiplayer solution that allows for the creation of Teams and other segmentation methods for players. Arc Teams was built from the ground up to support networked multiplayer games. It powers multiple games, each with different styles of segmenting players. ArcTeams supports both runtime and design time Team Definitions, allowing you to create any type of Team.  <p>Unreal Marketplace \u2022 Documentation</p> </li> </ul> <p>And more to come!</p>"},{"location":"arccommunication/","title":"Home","text":"<p>Unfinished Plugin</p> <p>Arc Communication is not finished.  Some features may be missing or unfinished.  Pardon the dust</p>"},{"location":"arccommunication/#description","title":"Description","text":"<p>Arc Communication is a full featured text chat and voice chat suite for multiplayer video games on Unreal Engine.  Supporting multiple channels, user generated routing, and localized messages, Arc Communication can support all your communication needs in a multiplayer game.</p>"},{"location":"arccommunication/#technical-details","title":"Technical Details","text":""},{"location":"arccommunication/concepts/localizedmessages/","title":"Localized Messages","text":"<p>Unfinished Plugin</p> <p>Arc Communication is not finished.  Some features may be missing or unfinished.  Pardon the dust</p> <p>Localized Messages are Arc Communication's method for sending text and stylized messages to players.  All messages, from chat to a killfeed to player join/leave notifications to achievement toasts can be represented as a Localized Message.</p> <p>Localized Messages are a UObject that is created on the client per-message.  When a Client recieves a localized message, the Server sends it a Subclass of the localized message class and a struct of relevant information for that message.  The Client then constructs the localized message object and forwards it to UI for rendering. </p> <p>Localized Messages are intended to be subclassed in BP or C++ for a given message type.  Included in the Localized Message class is a UMG Widget subclass for rendering the Message (See User Interface for more information).  While Localized Messages can be rendered without a custom widget, creating a widget is what allows for styling and making Localized Messages look different from each other.</p>"},{"location":"arccommunication/concepts/localizedmessages/#sending-localized-messages","title":"Sending Localized Messages","text":"<p>Localized Messages can be sent to clients in many ways, from the client or the server.  </p> <p>The primary method is a player sending a Chat message to a Route, by way of the ArcCommComponent_Player.  This can be done with the <code>Chat [Channel] [Message]</code> console command, or called directly in C++ or Blueprint.  This will send a string to the server to act as a chat message, and will be sent back as a TextMessage object.</p> <p>The secondary method, if you wish to broadcast other types of messages, is to call <code>SendLocalizeddMessage</code> directly, with a Message, Route, and the message data.  This is a far more powerful method of sending message and crafting them to send, but may require some custom validation on the server.  This can be called in BP or C++</p> <p>From the server, you can broadcast messages from the ArcCommComponent_Gamemode.  If you simply wish to send an arbirtrary string, you can use <code>BroadcastTextMessage</code> to send a message from any sender.  Giving that function a PlayerState will imply that that player sent that text message.  </p> <p>If you want to send a custom message, you can use <code>BroadcastMessage</code>.  This can be called from BP or C++.  It requires formatting the message yourself, but gives full power when sending any message to clients, such as a kill feed, a Join/Leave message, or any other messages you wish to send.</p>"},{"location":"arccommunication/concepts/localizedmessages/#built-in-localized-messages","title":"Built in Localized Messages","text":"<p>Most messages will need to be defined for your implementation, but Arc Communication provides a few pre-made message types.  </p>"},{"location":"arccommunication/concepts/localizedmessages/#uarccommlocalmessage_textmessage","title":"UArcCommLocalMessage_TextMessage","text":"<p>Text Message is the main local message for player chat.  A valid Text Message subclass must be provided to the Game Mode Component so it can properly send text to clients in a chat context.</p>"},{"location":"arccommunication/concepts/localizedmessages/#uarccommlocalmessage_joinleavenotification","title":"UArcCommLocalMessage_JoinLeaveNotification","text":"<p>Not Implemented Yet</p> <p>The JoinLeave Notification message is sent whenever a player joins or leaves the server.  If the server doesn't have a valid JoinLeave notification message, it wont send the notifications to everyone.  </p>"},{"location":"arccommunication/concepts/routers/","title":"Routers","text":"<p>Unfinished Plugin</p> <p>Arc Communication is not finished.  Some features may be missing or unfinished.  Pardon the dust</p> <p>Routers are the primary object for sending message data to clients.  All messages, text or voice, are sent along a Route, and Routers must be set up to determine which clients will recieve anything pushed over that route.</p> <p>Routes are denoted by a <code>FGameplayTag</code>, and Routers determine which messages are handled through a <code>FGameplayTagQuery</code>.  Many Routers can apply to a single route, and messages are only sent over the Route if all Routers agree that a reciever can recieve a given message from a sender.</p> <p>Messages can be sent by any Actor in the scene.  When a message is sent by a Player, the Sender is that player's Player State.  This can be used to create a notification system or voice broadcasting system, in addition to player-sent chat.</p>"},{"location":"arccommunication/concepts/routers/#basic-setup","title":"Basic Setup","text":"<p>To add new routes for messages, you must add them to the Arc Communication Gamemode Component.  You can have any number of routes in the component, and can have multiple Tag Queries match the same route.  </p> <p>If multiple Route Queries match with a given message or VOIP broadcast, all Routers must agree that a given reciever can recieve that message.  If any Router denies the message to be sent to that client, the message is not sent to that client.  </p> <p>Note</p> <p>If a client is not eligible to recieve a message due to the router declining the message, the server will not send anything across the network to that client regarding that message.  A client may not recieve a message they sent themselves, if the route declines sending it back ot them.  Do not assume you will recieve a message.</p> <p>For example, if you wanted to create a set of routes [<code>Chat.All</code>, <code>Chat.Team</code>, <code>Chat.Announcements</code>], and have All and Team only be able to be sent messages by players and Announcement can only be sent to by the server, and have All and Announcements go to everyone, you would set up 4 routers:</p> <ul> <li>Router 1: ANY(Chat.All, Chat.Announcement), Router Class: ArcComRouter_All</li> <li>Router 2: ANY(Chat.All, Chat.Team), Router Class: ArcCommRouter_RequiresValidSender</li> <li>Router 3: ANY(Chat.Announcement), Router Class: ArcCommRouter_RequiresNoSender</li> <li>Router 4: ANY(Chat.Team) Router Class: YourCommRouter_Team</li> </ul> <p>The first router will route any messages sent to All and Announcements to everyone.  The second router will restrict the sender, requiring a valid player state to send to those routes.  Router 3 will prevent senders with a valid player state from sending to that route (thus requiring gameplay code to send it), and Router 4 is some hypothetical router that determiens if the sender and reciever are on the same team.  </p> <p>Such a router setup will also work for Voice channels.  </p>"},{"location":"arccommunication/concepts/routers/#built-in-routers","title":"Built In Routers","text":"<p>Arc Communication comes built in with a few routers to help get chat and voip working quickly.  You can create your own routers in C++ or Blueprint.  All built in routers work with Text or Voice.</p>"},{"location":"arccommunication/concepts/routers/#arccommrouter_all","title":"ArcCommRouter_All","text":"<p>The All router sends to every player on the server</p>"},{"location":"arccommunication/concepts/routers/#arccommrouter_requiresvalidsender","title":"ArcCommRouter_RequiresValidSender","text":"<p>The Requires Valid Sender router checks if the sender has a valid player state.  This is to validate that only players can send to this route.</p>"},{"location":"arccommunication/concepts/routers/#arccommrouter_requiresnosender","title":"ArcCommRouter_RequiresNoSender","text":"<p>The Requires No Sender router checks if the sender does not have a valid player state.  This is to ensure that players cannot send messages to this route, even if they want to.  Only gameplay code can send to this route, using an actor that is not a player.  See Sending Messages for more information.</p>"},{"location":"arccommunication/concepts/routers/#arccommrouter_proximity","title":"ArcCommRouter_Proximity","text":"<p>The Proximity router determines the distance between the sender and reciever, and if they are within a certain distance will send the message to that reciever.  The Proxmity Router determines the locations between any sender actor and the reciever.  </p>"},{"location":"arccommunication/concepts/ui/","title":"User Interface","text":"<p>Unfinished Plugin</p> <p>Arc Communication is not finished.  Some features may be missing or unfinished.  Pardon the dust</p> <p>To render localized messages and voip information, Arc Communication provides a number of built in UMG widgets to display text. </p> <p>Message rendering is split into two different parts, the Message View, and the Message Widget.  The View is a widget that holds a number of messages, while the Message Widget renders a Localized Message.</p> <p>Voip does Voip things when Voip is done.</p>"},{"location":"arccommunication/concepts/ui/#message-views","title":"Message Views","text":"<p>A Message View widget is a widget designed to display messages.  It implments the <code>BPI_LocalizedMessageViewReciever</code> interface.  The default implementation contains a FGameplayTagQuery used to determine if a View should recieve a message.  When received, the View Widget constructs a Message widget and applies the Localized Message to it.  </p> <p>You can implement your own \"meta view\" widget, that contains many children view widgets and implement the <code>BPI_LocalizedMessageViewReciever</code> interface on it.  From there, you can decide which view actually recieves the message.  </p>"},{"location":"arccommunication/concepts/ui/#messages","title":"Messages","text":"<p>A Message Widget is a widget that implements the <code>BPI_LocalizedMessageInterface</code> interface.  A classic chat message interface would display the Channel, the Sender, and the message.  A Message Widget can implement the display of the localized message however it wants, and is hosted in a view.  </p>"},{"location":"arccommunication/concepts/ui/#voip-notifications","title":"Voip Notifications","text":"<p>Not Implemented Yet</p>"},{"location":"arccommunication/concepts/voip/","title":"Voice","text":"<p>Unfinished Plugin</p> <p>Arc Communication is not finished.  Some features may be missing or unfinished.  Pardon the dust</p> <p>Not Implemented Yet</p>"},{"location":"arcinventory/","title":"Home","text":"<p>Welcome to the Arc Inventory documentation!</p>"},{"location":"arcinventory/#description","title":"Description","text":"<p>Arc Inventory is a Gameplay Ability System based inventory solution that allows for the creation of ability-powered items and inventory management, and can slot seamlessly into your GAS-based game. Arc Inventory is built from the ground up for multiplayer, and supports everything from passive items, active items, stacking items, and more. Using Arc Inventory, you can create shooter gameplay, RPG gameplay, and even procedurally generate items or create an attachment system.</p> <p>Arc Inventory is used in multiple games, and powers very different gameplay systems with this easy to use, designer focused system.</p> <p>Get it on the Unreal Marketplace: Marketplace Page</p>"},{"location":"arcinventory/#technical-details","title":"Technical Details","text":"<ul> <li>Inventory Components that support Bags, Equipment, and Active items.</li> <li>Fully integrated with Epic\u2019s Gameplay Ability System</li> <li>Supports Multiplayer</li> <li>Supports any game play mechanics GAS can do</li> <li>Easy to set up</li> <li>Requires minimal code</li> <li>Full Blueprint Integration</li> </ul> <p>Still need help?</p> <p>You can get support in our discord!</p> <p>Discord.gg/PunyHuman</p> <p>Plugin channels:</p> <ul> <li>#plugins-general</li> <li>#plugins-support</li> </ul>"},{"location":"arcinventory/faq/","title":"FAQ/Common Issues","text":""},{"location":"arcinventory/faq/#crashdisconnect-in-multiplayer-when-swapping-items-switching-items-or-using-any-of-the-built-in-inventory-abilities","title":"Crash/Disconnect in Multiplayer when swapping items, switching items, or using any of the built in Inventory abilities.","text":"<p>This crash often accompanies the error in your log. <pre><code>LogAbilitySystem: Error: Could not find GameplayAbilityTargetData_ItemSwitch in ScriptStructCache\nLogAbilitySystem: Error: Could not script struct at idx 2\n</code></pre></p> <p>This is caused by failure to init the Gameplay Ability System Globals.  You need to call <code>UAbilitySystemGlobals::InitGlobalData()</code>  The Arc Inventory Example Project contains a useful Engine Subsystem for this.  You can grab the Engine Subsystem from a github gist as well.</p> <p>You can find out more information in the community GAS documentation about Initing the Ability System.</p>"},{"location":"arcinventory/faq/#are-there-any-debug-overlays-or-tools-to-help-see-the-internal-state-of-the-inventory","title":"Are there any Debug overlays or tools to help see the internal state of the inventory?","text":"<p>There are!  Simply use the console command <code>ShowDebug Inventory</code> to view the internal state of the inventory.  This will display a list of all item slots for you.  </p> <p>If you want to see all of the items, set <code>ArcInventory.DebugDetailedItemInfo 1</code> in the console.  This will show detailed slot info and any detailed debug information for the item that is in that slot.  It's disabled by default (as the text can get very cluttered).</p>"},{"location":"arcinventory/initialsetup/","title":"Initial Setup","text":"<p>Thanks for purchasing Arc Inventory!  Once you've downloaded the plugin and enabled it in your project, this is how you start to use it!</p> <p>Info</p> <p>This plugin uses a lot of other Unreal Engine concepts to achieve full functionality.  It's recommended that you have a firm grasp on Unreal Engine, GAS, and Gameplay Tags</p> <ul> <li>GASDocumentation</li> <li>Unreal Engine Gameplay Tag documentation</li> </ul>"},{"location":"arcinventory/initialsetup/#optional-configuring-the-asset-manager","title":"Optional: Configuring the Asset Manager","text":"<p>Arc Inventory supports the Asset Manager to dynamically load items!  To set that up, you simply need to configure the Primary Asset Types for the Arc Inventory types.</p> Editor <p>In the Unreal Editor, go to View -&gt; Project Settings.  Select the Asset Manager category within Game.</p> <p>Add two entries in the <code>Primary Asset Types to Scan</code> array, and set them to be the following information:</p> <p></p> .ini <p>In your <code>DefaultGame.ini</code>, add the following tags to the <code>[/Script/Engine.AssetManagerSettings]</code> section (Create it if it doesn't exist)</p> <pre><code>+PrimaryAssetTypesToScan=(PrimaryAssetType=\"ArcItemGenerator\",AssetBaseClass=/Script/ArcInventory.ArcItemGenerator,bHasBlueprintClasses=True,bIsEditorOnly=False,Directories=((Path=\"/Game\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))\n+PrimaryAssetTypesToScan=(PrimaryAssetType=\"ArcItemDefinition_New\",AssetBaseClass=/Script/ArcInventory.ArcItemDefinition_New,bHasBlueprintClasses=True,bIsEditorOnly=False,Directories=((Path=\"/Game\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))\n</code></pre> <p>Note</p> <p>When to load asset data and best practices around the Asset Manager is out of scope for this documentation, but for development it is often easy to just load all assets of these types at game startup.  </p>"},{"location":"arcinventory/initialsetup/#for-ue-426-configuring-arc-inventory","title":"For UE 4.26, Configuring Arc Inventory","text":"<p>Note</p> <p>As of Unreal Engine 4.27, Configuring Arc Inventory is no longer needed.  If you use previous version of Arc Inventory, this section is still necissary.</p> <p>Your first step will be to configure the necissary tags for Arc Inventory's internal functions.  These are required, and many features will fail to function if these tags are not configured.  </p> Editor <p>In the Unreal Editor, go to View -&gt; Project Settings.  Select the Arc Inventory Developer Settings category within Game.</p> <p></p> <p>Deprecation Notice</p> <p><code>Ability Tag Mappings</code> is deprecated and unused.  It will be removed in future versions of Arc Inventory</p> .ini <p>in <code>DefaultGame.ini</code> the you can configure the following fields with tags:</p> <pre><code>[/Script/ArcInventory.ArcInventoryDeveloperSettings]\nEquippedSlotTag=(TagName=\"Inventory.Slot.Equipment\")\nActiveItemSlotTag=(TagName=\"Inventory.Slot.Active\")\nBagItemSlotTag=(TagName=\"Inventory.Slot.Bag\")\nItemSlotSwapAbilityTags=(GameplayTags=((TagName=\"Ability.Inventory.SwapItemSlot\")))\nItemSlotDropAbilityTags=(GameplayTags=((TagName=\"Ability.Inventory.DropItems\")))\n</code></pre> <p>Warning</p> <p>Ensure that the tags are defined in your <code>GameplayTags.ini</code> or however else you've configured gameplay tags!</p> <p>Once the tags are configured, the Plugin is setup and ready to go!  You are ready to add the Inventory Component to your player!</p>"},{"location":"arcinventory/usefulresources/","title":"Useful Resources","text":"<ul> <li>GASDocumentation</li> <li>Unreal Engine Gameplay Tag documentation</li> </ul>"},{"location":"arcinventory/changelogs/1.2.0/","title":"1.2.0","text":""},{"location":"arcinventory/changelogs/1.2.0/#the-one-that-shipped-on-the-marketplace","title":"The one that shipped on the Marketplace","text":"<ul> <li> <p>Removed the dependency on Arc Core.  This has some far reaching effects on the plugin</p> </li> <li> <p>Active Item's Active Ability struct no longer uses a Tag &lt;-&gt; Ability map.  Instead it's now a flat array with a UArcInvInputBinder instanced object</p> <ul> <li>Arc Inventory contains a simple input binder for use.  It just takes an int32 and returns it.</li> <li>Arc Inventory Extras contains a TagMap input binder, but depends on ArcCore.  This restores the previous functionality</li> <li>You can implement your own input binder.  Simply store some kind of information regarding how to return a int32 input binding to adding and return it in the implementable function GetInputBinding.  The ASC and Ability being granted are passed into the function.  This can be implemented in blueprint as well.</li> </ul> </li> <li> <p>Deprecated the Held Item Interface.  Attaching weapons to hands, if your game needs it, can be done in the OnItemActive and OnItemInactive events in the Active Inventory Component.  These events are called on the client and the server, and are called in a predictive context.  </p> </li> <li> <p>Removed the ArcInteractable Interface due to removing ArcCore dependency.  Games need to implement how to interact with World Items now.  An example pickup ability is provided in Arc Inventory Extras</p> </li> <li> <p>Predicted Active Item Swaping.  Using the <code>SwapActiveItem</code> function, you can now swap items instantly and predictively, such as with an ability.  The Example project has an example of how to predictively swap weapons.</p> </li> <li> <p>Bugfix: Fixed a timing issue at game startup where the Active Item was incorrect</p> </li> <li>Improvement: Exposed the Active Item Slot's slot index to blueprint</li> <li>Bugfix: added ARCINVENTORY_API to two IsValid functions</li> <li>Change: The source object for abilities added to the player is the item that granted them. </li> <li>Bugfix: IWYU Fixes</li> </ul>"},{"location":"arcinventory/changelogs/1.2.1.106/","title":"1.2.1.106","text":""},{"location":"arcinventory/changelogs/1.2.1.106/#the-one-that-properly-checks-slots","title":"The one that properly checks slots","text":"<ul> <li>Fix Swapping items not working when a slot has an item</li> <li>Created a AcceptsItem_AssumeEmptySlot function to test if the slot can hold an item, assuming the slot is empty.  AcceptsItem retains it's previous behavior of failing due to a full slot.  </li> </ul>"},{"location":"arcinventory/changelogs/1.2.2.113/","title":"1.2.2.113","text":""},{"location":"arcinventory/changelogs/1.2.2.113/#the-one-that-updates-to-426","title":"The one that updates to 4.26","text":"<ul> <li>Updated to 4.26</li> <li>Improvement: Only swap item stack's owner if the owner is different than the inventory it's in.</li> </ul>"},{"location":"arcinventory/changelogs/1.2.3.115/","title":"1.2.3.115","text":""},{"location":"arcinventory/changelogs/1.2.3.115/#the-one-that-allows-for-item-transfer-between-inventories","title":"The one that allows for item transfer between inventories","text":"<ul> <li>Added a blueprint bindable event for when items are Equipped and Unequipped in the Equippable Inventory</li> <li>Improved SwapItemSlots<ul> <li>Now accepts ItemSlots from other inventories</li> <li>Will swap the items in another inventory with an item in our inventory</li> <li>Will fail if both FromSlot and ToSlot aren't the in the inventory </li> <li>Will still fail if the filters disallow the item in either slot</li> </ul> </li> </ul>"},{"location":"arcinventory/changelogs/1.2.4.118/","title":"1.2.4.118","text":""},{"location":"arcinventory/changelogs/1.2.4.118/#the-one-that-makes-items-inactive-when-removed-from-the-slot","title":"The one that makes items inactive when removed from the slot","text":"<ul> <li>Fixed a bug where items are not properly set inactive when removed from an active item slot</li> <li>fixed an issue where an active item slot is not made inactive on the client if the item is removed from the slot right before being updated. </li> </ul>"},{"location":"arcinventory/changelogs/1.2.5.123/","title":"1.2.5.123","text":""},{"location":"arcinventory/changelogs/1.2.5.123/#the-one-that-changes-attribute-initialization","title":"The one that changes attribute initialization","text":"<ul> <li>Added a callback when attribute sets are created so consumers can set attribute data</li> <li>New method of initalizing attribute sets.<ul> <li>Attribute sets are no longer stored as instanced objects in the default object.  Instead they are stored as subclasses.  A Map is provided in each ability info to select which attributes you wish to override when initalizing those attribute sets, and the value is set.  This supports both float and FAttributeData backed attributes. <li>Setting an Attribute to override sets it's base value</li> <li>Added a tool to convert the old attribute init system to the new one</li> <li>Deprecated 'Attribute Sets'.  This will set the 'Attribute Sets' property in the AbilityInfo struct to read-only.  You'll still be able to view your data, but it will be unused.  </li> <li>Removed the depricated and read only <code>FGameplayTag, TSubclassOf&lt;UGameplayAbility&gt;</code> ActiveAbilities map.</li>"},{"location":"arcinventory/changelogs/1.2.6.129/","title":"1.2.6.129","text":""},{"location":"arcinventory/changelogs/1.2.6.129/#the-one-that-fixes-some-caching-issues","title":"The one that fixes some caching issues","text":"<ul> <li>Fixed an issue where creating and removing dynamic item slots would reuse a slotid, causing slot reference collisions</li> <li>Fixed a few cases where modifying an item stack would not mark the slot array dirty, causing it to not send updates to the client.  </li> <li>Removed COND_OwnerOnly from ItemName for items.  Now everyone can see the name of the item</li> <li>Fixed a bug where Bag Inventory Widget would always look for the owning parent's inventory.  It now allows setting the target inventory for view</li> <li>Fixed an issue where Item Slot Widgets would cache the parent inventory and that cache could not be cleared.  You can now refresh Item Slot Widgets and they will find the inventory again.  </li> </ul>"},{"location":"arcinventory/changelogs/1.2.7.131/","title":"1.2.7.131","text":""},{"location":"arcinventory/changelogs/1.2.7.131/#the-one-that-stops-loops-from-going-infinite","title":"The one that stops loops from going infinite","text":"<ul> <li>Added a OnRep functions for all replicated properties to UArcItemStack.  They can be overriden by child classes</li> <li>Fixed a case where GetPreviousValidActiveItemSlot and GetNextValidActiveItemSlot could get stuck in an infinite loop if you tried to find the next valid item slot when you didn't have an item active.  </li> </ul>"},{"location":"arcinventory/changelogs/1.2.8.132/","title":"1.2.8.132","text":""},{"location":"arcinventory/changelogs/1.2.8.132/#the-one-that-fixes-cross-inventory-item-swapping","title":"The one that fixes cross inventory item swapping","text":"<ul> <li>Removed Initial Only repication from ArcItemStack's ItemDefinition Property</li> <li>Reworked cross-inventory item swapping, so it functions properly now</li> </ul> <p>Arc Inventory Example Updates</p> <ul> <li>Fixed the item tag usage so the drop item ability works by default</li> <li>Fixed the binding of the chest UI to the owning inventory, so it properly displays now</li> <li>Fixed the binding of the active item slots to the owning pawn in local hosted environments, so they should display the items properly now (single player and listen server host)</li> </ul>"},{"location":"arcinventory/changelogs/1.2.9.134/","title":"1.2.9.134","text":""},{"location":"arcinventory/changelogs/1.2.9.134/#the-one-that-fixes-replication-for-map-placed-objects","title":"The one that fixes replication for map-placed objects","text":"<ul> <li>Removed \"Is Name Stable for Networking\" in ArcItemStack.  ArcItemStacks are never name stable.  A dynamic netguid should always be created for them</li> <li>Properly replicate sub-items for sub-items.  </li> </ul>"},{"location":"arcinventory/changelogs/1.3.0.138/","title":"1.3.0.138","text":""},{"location":"arcinventory/changelogs/1.3.0.138/#the-one-that-replicates-subitemstacks-better","title":"The one that replicates subitemstacks better","text":"<ul> <li>Fixed the ArcInventoryComponent's <code>OnItemSlotChange</code> event on the client.  It should now mirror the same parameters as the server's version.</li> <li>Reworked Subitem replication.  Due to an issue with Unreal Engine replication during the initial replication frame, UArcItemStack's SubItem array was being updated before the subitems were being created.  This would lead to the array having null entries when an item is replicated to the client, but only for a frame.  The next frame, the NetDriver would fixup the pointers and it would be valid.  </li> </ul> <p>To Fix this, UArcItemStack's SubItem array has been changed to a FFastArraySerializer struct.  This necissitated an API change, thus the version increment.  Now, there is an event when a SubItem is added or removed from the SubItemStacks array, and binding to that event will catch when the netdriver fixes up the sub item stack pointers.  You will still get null sub item stacks in the array if you try to access the array on the initial replication frame of a new item.</p> <ul> <li>Changed UArcItemStack's GetSubItemStacks blueprint node from a getter to a blueprint pure function that returns an array.</li> <li>Modified BP_SimpleLargeItemCard to account for the SubItemStack changes</li> </ul>"},{"location":"arcinventory/changelogs/1.3.1.144/","title":"1.3.1.144","text":""},{"location":"arcinventory/changelogs/1.3.1.144/#the-one-that-better-supports-ue5","title":"The one that better supports UE5","text":"<ul> <li>Fixed a number of deprecations in UE5</li> <li>Removed the Force Replication code.  It didn't quite work, and was causing issues</li> <li>Fixed an include error in certain build configurations</li> </ul>"},{"location":"arcinventory/changelogs/1.3.2.145/","title":"1.3.2.145","text":""},{"location":"arcinventory/changelogs/1.3.2.145/#the-one-that-fixes-a-cross-inventory-regression","title":"The one that fixes a cross-inventory regression","text":"<ul> <li>Fixed a regression in Cross-Inventory item swapping that the UE5 support work introduced.  </li> </ul>"},{"location":"arcinventory/changelogs/1.3.3.150/","title":"1.3.3.150","text":""},{"location":"arcinventory/changelogs/1.3.3.150/#the-one-that-stacks-items-and-fixes-bugs","title":"The one that stacks items and fixes bugs","text":"<ul> <li>Blueprint Rework: Updated the Swap Item Stack ability to be aware of mergeable item stacks.  It will now attempt to merge item stacks that can be merged, rather than just swapping their positions</li> <li> <p>Blueprint Rework: Updated the Item Slot Widgets to show the item's stack size if it has one.  </p> </li> <li> <p>Fixed Equipped Ability Info not being set on Active Item Slots</p> </li> <li> <p>Added a NetSerializer to the ItemSlotFilter so it is properly replicated to clients</p> </li> <li> <p>Merge Item Stacks no longer cuts off some stacks if otherstack size is too large</p> </li> <li>Stack size is now replicated to everyone</li> <li>Invalid static slot variables are now implemented in .cpp, fixing linker errors</li> <li>Item Def's DefaultItemStackClass was unused.  It's not chosen instead of the Item Generator's class depending on which item class is more specialized (Generator's is chosen if it's more specialized and vice versa)</li> </ul>"},{"location":"arcinventory/changelogs/1.4.0.157/","title":"1.4.0.157","text":""},{"location":"arcinventory/changelogs/1.4.0.157/#the-one-that-updates-to-427","title":"The one that updates to 4.27","text":"<ul> <li> <p>Fixed a bug where abilities weren't being applied if they shared the same class as an ability on another item, and you were switching items that frame.  We now check if the ability is Pending Remove when the same class ability exists, and add our new ability anyway if the old ability is pending remove</p> </li> <li> <p>Updated tags to use NativeGameplayTags </p> <ul> <li>Defined Tags:    <ul> <li><code>Inventory.Slot.Bag</code> </li> <li><code>Inventory.Slot.Equipped</code> </li> <li><code>Inventory.Slot.Active</code> </li> <li><code>Ability.Inventory.DropItem</code> </li> <li><code>Ability.Inventory.SwapItems</code> </li> <li><code>Ability.Inventory.SwapPending</code></li> </ul> </li> </ul> </li> </ul> <p>These Tags are now defined automatically by the plugin, and will show up in all places gameplay tags are found.  You no longer need to define them yourself.</p> <p>Note</p> <pre><code>If you have your own custom tags set up in the Arc Inventory Developer Settings, you'll need to update your tags to match these.\n</code></pre> <ul> <li>Removed Deprecated AbilityTagMappings from the arc inventory gameplay tag settings </li> <li>Removed Deprecated Attribute set field from item def ability info, and removed the tools to convert from this to the new ability mapping  </li> <li>Removed Deprecated HeldItemInterface</li> <li>Removed Unusued ArcInventoryLocalPlayerSubsystem</li> </ul>"},{"location":"arcinventory/changelogs/1.4.1.163/","title":"1.4.1.163","text":""},{"location":"arcinventory/changelogs/1.4.1.163/#the-one-that-cleans-up-some-c-linking-issues","title":"The one that cleans up some c++ linking issues","text":"<ul> <li>New: LootItem and PlaceItemIntoSlot now attempt to stack items into other items that allow stacking.  Both may return false now if the item was partially added to the inventory.</li> <li>New: SwapItemSlots now accepts empty item slots as valid swap targets</li> <li>Fix: Added ARCINVENTORY_API to a number of constants and the native tags</li> <li>Fix: Fixed a linux linker error in unity builds caused by reusing a same name.  This only occours on clang.</li> </ul>"},{"location":"arcinventory/changelogs/1.4.2.174/","title":"1.4.2.174","text":""},{"location":"arcinventory/changelogs/1.4.2.174/#the-one-for-unreal-50","title":"The one for Unreal 5.0","text":"<ul> <li> <p>Updated to Unreal 5.0!</p> </li> <li> <p>Fixed an ensure that could hit when the plugin was re-registered with an actor</p> </li> <li>Added support for unbinding from an AbilitySystemComponent, used in situations where the ASC is on the Player State and the pawn is changed.  <ul> <li>This will remove all of the abilities, effects, and tags from any item from the ASC.  It does not destroy everything though, so they can be placed right back on an ASC when the owning actor regains it's ASC.</li> <li>This does not happen automatically.  You must call BindToASC() and UnbindFromASC() when you remove an ASC from the owning actor.  </li> </ul> </li> <li>Added support for adding the same ability multiple times to an ASC</li> <li>Added a utility function to copy an inventory from one Inventory Component to another.  </li> <li>Fixed a crash when trying to get an inventory comp from a null actor (now just returns null)</li> <li>Fixed a crash when a stored attribute set goes null for whatever reason</li> <li>Fixed attribute sets being owned to the owner of the inventory and not the owner of the owner's ASC</li> </ul>"},{"location":"arcinventory/concepts/generators/","title":"Item Generators","text":"<p>Item Generators are the factory that produces items.  Because of the need to create Item Stacks and associate them with Item Definitions, It becomes fairly involved to create new items on demand.  Item Generators seek to bridge that gap and allow control over the item production process.</p> <p>Most games will not need to use Item Generators.  It is very common for a game to create a single Item Generator, set the Item Definition for it to spawn, and then spawn that item.  This is perfectly fine, and it is recommended for most games starting out using the system.  The Example Project uses this method to generate items.  </p> <p>However, if you need more control over the process of creating items, Arc Inventory gives you a lot of it.</p>"},{"location":"arcinventory/concepts/generators/#basic-setup","title":"Basic Setup","text":"<p>Item Generators require subclassing UArcItemGenerator and overriding the <code>GenerateItemStack_Implementation</code> function.  This can be done in Blueprint.   </p> <p>Inside that function, you simply need to return a <code>UArcItemStack</code> pointer.  Most item generators will call <code>CreateNewItemStack</code> with the Defintion and an optional rarity, do some work on the item stack, and then return it.  </p> <p>Tip</p> <p>You can create as many item stacks as you need in a single generator, which is useful for generating SubItems to attach to your item!</p> <p>Arc Inventory contains a few built in item generators, including a Static Item Generator class for embedding into property editors, and a Unique Item Generator for customizing all of the components of item geration in the property editor.  </p>"},{"location":"arcinventory/concepts/generators/#procedural-generation","title":"Procedural Generation","text":"<p>Arc Inventory also supports the procedural generation of items through Item Generators.  Included in the plguin is a Simple Random generator that produces 'Perks' and attaches Sub Items to items, based on item rarity.  </p> <p>The Simple Random generator uses a weighted random algorithm to determine how common certain elements are, and uses child item generators to produce sub items that are attached to the parent item, with a number based on the rarity.  </p> <p>Simple Random is intended to be an example.  While projects may use it, Procedural Generation of items is generally a game specific mechanic, and it's advised that you create your own generator for procedural generation.</p>"},{"location":"arcinventory/concepts/highlevel/","title":"High Level","text":"<p>At the highest level, Arc Inventory is an inventory that allows you to power your game code with GAS, and to give you a lot of power over the design and development of your game.</p> <p>The Inventory System's primary purpose is to give your character and pawns a set of Gameplay Effects, Abilities, and Attributes, and control how and when those are added to and removed from your character's ASC.</p>"},{"location":"arcinventory/concepts/highlevel/#project-goals","title":"Project Goals","text":"<p>Arc Inventory has a few goals, and they are reflected in every part of the inventory system.</p> <ol> <li> Don't Assume Game Design Arc Inventory will not assume your design or make design choices for you.  The core structure can be reused across many genres of game, from RPGs to FPSes to Survival games to Action RPGs. Inventory accomplishes this by breaking up different inventory concepts across the system and classes.  </li> <li> Let the user subclass Arc Inventory attempts to be a general base for GAS powered inventory, but because of #1, it does not make a lot of game design choices like Input or complex UI.  Because of this, every part of the system is intended to be subclasses to fill out features.   </li> <li> The Character Does the Work Arc Inventory makes the character do the work, and is intended to be a component on your character.  Items, ItemDefs, and all pieces are simply bits of information for your character to react to.  Things like how your character actually holds the item or what happens when you activate an item is easily scripted, but must be done on the character or inside of an Gameplay Ability. </li> </ol>"},{"location":"arcinventory/concepts/highlevel/#inventories","title":"Inventories","text":"<p>Inventories are the primary container for Items.  Inventory is an actor component that handles the placement of items into Slots.  The Inventory has many subclasses to enable different types of functionality, and care should be taken to decide which class is right for your game.</p> <p>At it's core, Inventories are an array of <code>Inventory Slots</code>.  Slots are defined with a set of Gameplay Tags, and can have an Item Filter to indicate which items can be placed into the slot.  </p> <p>Inventory Slots are split into 3 different concepts, <code>Bag</code>, <code>Equipment</code>, and <code>Active</code>.  </p> <code>Bag Slot</code> Bag Slots are slots that can generally hold any item, but do not do anything when an item is placed into them.   <code>Equipment Slot</code> Equipment Slots are slots that generally hold specific items, and place GAS primitives onto the component owner when the item is put into the slot.   <code>Active Slot</code> Active slots are slots that hold specific items, and only one item can be active at a time of all items in active slots.  These can be thought of as held items for a first person shooter or a sword that the player is currently wielding. <p>Tip</p> <p>A slot can be any combination of <code>Bag</code>, <code>Equipment</code>, or <code>Active</code>.  It's very common for Active Slots to also be Equipment Slots!</p> <p>Caution</p> <p><code>Equipment</code> and <code>Active</code> slots only have meaning when using their corrisponding subclass of UArcInventoryComponent.  See the Inventory page for more details!</p>"},{"location":"arcinventory/concepts/highlevel/#items","title":"Items","text":"<p>Items are split into two different concepts, the <code>Item Stack</code> and the <code>Item Defininition</code>.  </p> <code>Item Stack</code> A Replicated UObject that contains instance-specific data for a given item.  It's very light and thin to support many items being replicated <code>Item Definition</code> A default-object only blueprint class that contains all of the static data for each item. <p>These concepts are split to allow Item Stack to be as light as possible with replication.  </p> <p>Info</p> <p>It is intended that you subclass both <code>UArcItemStack</code> and <code>UArcItemDefinition</code> for your custom implementations</p>"},{"location":"arcinventory/concepts/highlevel/#item-generators","title":"Item Generators","text":"<p>Item Generators are factories for creating items.  An item generator can be as simple as just tying together an Item Definition or as complex as procedurally generating an item with multiple prefixes, suffixes, and random stats.  </p>"},{"location":"arcinventory/concepts/inventory/","title":"Inventory","text":"<p>Inventory is the primary container for items, and the primary controller for what items do to players.  </p> <p>Inventory is implemented as an Actor Component, and has many children classess to cover different gameplay functions.  The base class, <code>UArcInventoryComponent</code> features the core slot structure, placing items into slots, and allowing developers to understand the layout of their inventory through queries.  </p>"},{"location":"arcinventory/concepts/inventory/#base-inventory","title":"Base Inventory","text":"<p>The Primary mechanism for the base inventory is to manage and replicate Slots.  It also watches if items move in those slots, and handles the insertion and removal of items</p> <p>The underlying data layout is hidden from implementors, and the public API handles all edge cases around Replication, Ownership, and reports back failure states.</p> <p>Warning</p> <p>If a function returns a bool, that means that it can fail.  It is up to you to determine how to handle that failure.  Not catching failure states can lead to Items being lost!</p>"},{"location":"arcinventory/concepts/inventory/#slots","title":"Slots","text":"<p>Slots are the primary container for items.  The underlying replication type, <code>FArcItemSlot</code> is not exposed to the public API, but it covers the details of replication and ensuring that slots are synchronized between client and server.  The public API exposes a <code>FArcItemSlotReference</code>, which contains a all the data needed to reference a slot in an inventory.  All functions that refer to inventory slots take a <code>FArcItemSlotReference</code>, and for all purposes, that is the item slot.  </p> <p>Note</p> <p>Always check if the slotref is valid before attempting to access it or pass it into an inventory.  </p> <p>Warning</p> <p><code>FArcItemSlotReference</code> contains a weak pointer to the owning inventory.  If that inventory is destroyed, the slotref will be invalid.  It is not recommend that you store a slotref across multiple frames.  It is recommend that you either strongly control the data lifetime, or query for the slot when you need it.  </p>"},{"location":"arcinventory/concepts/inventory/#slot-queries","title":"Slot Queries","text":"<p>Slot Queries are the concept for access data inside of an inventory.  They are represented by <code>FArcInventoryQuery</code>.  They have two properties, <code>ItemTypeQuery</code> and <code>SlotTypeQuery</code>.  Item Query functions are generally prefixed with <code>Query_</code>, and the different Query functions allow accessing different types of slots. </p> <p>ItemType and SlotType can be used interchanably.  ItemType looks for the item in the slot and matches tags on the item's tags.  ItemType queries automatically fail on slots that are empty.  SlotType Query searches the tags on each slot.    </p>"},{"location":"arcinventory/concepts/inventory/#slot-filters","title":"Slot Filters","text":"<p>Slot Filters allow designers to indicate what items can be placed into the slot.  Slot Filters contain a GameplayTagQuery to search the tags on a given item, and whether or not to force that slot to contain a single stack.  If there is no TagQuery, the slot accepts all items.</p>"},{"location":"arcinventory/concepts/inventory/#notable-functionsproperties","title":"Notable Functions/Properties","text":"<ul> <li> <code>CustomInventorySlots</code> An EditDefaultsOnly Array of Item Slot definitions.  This is where you design out all your slots that have custom functionality.  It is very common to have a dozen or more slots defined here.   </li> <li> <code>CreateInventorySlot</code> / <code>RemoveInventorySlot</code> Protected runtime creation of inventory slots.  It's protected so you can access these by subclassing your inventory, but allows you to create and remove item slots.  Everything replicates fine when creating and removing slots.   </li> <li> <code>PlaceItemIntoSlot</code> Places an item into a slot.  Will fail if the slot already has an item. Always check the return value of this function, and handle failure accordingly.  It is common to call LootItem if PlaceItemIntoSlot fails.  </li> <li> <code>LootItem</code> Places an item into the first slot it can.  The order it checks slots is not garuanteed, so it could end up in slots you don't expect.  If it fails, that means that item cannot possibly fit into the inventory, and failure should be handled. </li> </ul> <p>Caution</p> <p>If placing an item into a slot succeeds, it is recommend to discard the pointer to the item you currently have.  Internally, the Inventory will remap the owner of the items, sometimes Duplicating the object (this is to deal with problems with Unreal Replication).  </p>"},{"location":"arcinventory/concepts/inventory/#bag","title":"Bag","text":"<p>Bag is the first subclass of the base inventory.  Bag inventory creates a number of \"Bag Slots\", which are slots without item filters.  The number of bag slots can be 0.  You can also bind the number of slots to a Gameplay Attribute to change the number of bag slots at runtime.  </p> <p>Tip</p> <p>If you bind the bag slot gameplay attribute, you can change that attribute with an item!  </p>"},{"location":"arcinventory/concepts/inventory/#equipment","title":"Equipment","text":"<p>Equipment slots are slots with the Equipment tag as defined project settings.  When an item is placed into this slot, a callback will fire indicating that the item is equipped.  If your item has an item definition derived from <code>UArcItemDefinition_Equipment</code>, then it will activate the equipped item information and placed the GAS primitives on the player.</p> <p>Tip</p> <p>Use Equipment slots to hold things like armor in an RPG game, skills in a Overwatch-style hero shooter or MOBA, or stat-stick weapons in a Diablo or Path of Exile style Action RPG!</p>"},{"location":"arcinventory/concepts/inventory/#active","title":"Active","text":"<p>Active Inventories are inventories with a set of slots defined with the Active Slot tag.  In an active inventory, only one slot can be active at a time, and when that slot is active a callback is issued.  If an item is in the slot with a definition that derives from <code>UArcItemDefinition_Active</code>,  then the GAS Primitives in the Active Item Info property will be applied to the character.</p> <p>Tip</p> <p>Use Active Inventories for FPS or RPG games where your character can only hold one item at a time!</p> <p>Info</p> <p>If these subclasses do not support your game type, it is easy to extend an inventory component and add your own functionality.  Most games create their own Inventory Component with their own functionality when items are placed into certain slots!</p>"},{"location":"arcinventory/concepts/itemstack/","title":"Item Stacks","text":"<p>The second concept is the Item Stack, or Item Instance.  Item Instancing can get very heavy with a lot of data, and Arc Inventory takes care to make each item as light as possible, while still being extendable.  To achieve this, Arc Inventory creates two concepts for storing item data, the Stack and the Definition.  The Item Stack is the per-instance data, and only data that is necissary is included in it.  The Item Definition is the static data that doesn't change across instances, like the abilities an item grants or it's mesh.  </p> <p>The difference between an Item Stack and an Item Defition is important and a key concept to understand with Arc Inventory</p> <p>Tip</p> <p>It is possible and intended to extend both Item Stack and Item Definition.  Extending Item Definition to add your own static data is extremely common.  Extending ItemStack is less common, but if you need to replicate per-instance data, it can be easily done.</p>"},{"location":"arcinventory/concepts/itemstack/#item-stacks","title":"Item Stacks","text":"<p>Item Stacks are derived directly from UObject, and are replicated inline with the inventory (or other replicated actor who owns the stack).  Item Stacks are extremely thin, and only replicate and contain necissary information for the instance of the object.  The contain the full representation of an item, including the item definition</p> <p>Warning</p> <p>Internally, Item Stacks are duplicated or moved around, so a pointer to an item stack may expire when transfering items across inventories.  This is to help better support replication, but does mean that it's required to discard pointers to items when transfering item stacks or merging them.</p> <p>Item Stacks can have a stack size, meaning multiple items of the same definition can be combined into one single object.  They can be merged and split, creating new item stack objects in the process.  The Item Definition must allow items to do this, and two item stacks with different sub-items cannot be merged.</p> <p>Item Stacks also hold instanced attribute sets for the instanced attribute system.  When the inventory needs to store off attributes or active gameplay effects, it does so by storing them in the Item Stack.</p>"},{"location":"arcinventory/concepts/itemstack/#sub-item-stacks","title":"Sub Item Stacks","text":"<p>Item Stacks can contain a list of Item Stacks as \"Sub Items\".  These are fully functional items with definitions that are attached to the parent item.  Sub Items can be nested indefinitely.  This can be used to create a component system. </p> <p>Sub Items are replicated inline, and every item can have different sub items.  They are ideal for replicating option information with certain item instances.  </p> <p>Tip</p> <p>Use Sub Item Stacks to implement perks, attachments, or even firing modes on your items!</p>"},{"location":"arcinventory/concepts/itemstack/#item-definitions","title":"Item Definitions","text":"<p>Item Definitions are the static data for items.  They are used as class definitions and CDOs only, never instanced.  In this regard, they can be very lightly replicated, and are key to high performance in the system.</p> <p>Item Definitions carry all of the data required to make the item work.  They are often subclassed to add more data depending on the usage of that item, and easily support all kinds of data.  Different subclasses of the Inventory Component do work with the data in an Item Definition to achieve functionality.</p> <p>Note</p> <p>It is the Inventory that applies GA primitives to the character.  The Item Definition simply contains that data.  </p>"},{"location":"arcinventory/concepts/itemstack/#world-stacks","title":"World Stacks","text":"<p>Given that Item Stacks and Item Definitions are not actors, Items cannot be placed in the game world.  Since this is a common need for inventory systems, Arc Inventory contains a class, <code>AArcItemStackWorldObject</code>, which implements basic replication and visuals for an item. </p> <p>It is recommended that you set up a subclass of this actor, and override the setting in the Project Settings to use it.  You can use <code>UArcItemBPFunctionLibrary::SpawnWorldItem</code> or the <code>Spawn World Item</code> function in blueprint to spawn World Items easily.  </p> <p>Tip</p> <p>If you want different items to behave differently when spawned into the world, you will need to spawn the World Stack yourself, and call <code>SetInventoryStack</code> on it with the item stack you wish to assign.</p>"},{"location":"arcinventory/concepts/ui/","title":"User Interface","text":"<p>User Interface is a common requirement for Inventory systems, but often requires unique and game specific implementations to achive the best look.  To this end, Arc Inventory provides a few building blocks for development inventories, but expects that user implement their own stylized views.  </p> <p>Arc Inventory follows the MVC pattern for UX, with Inventory/Items acting as the Model, UMG Widgets acting as the View, and Game Framework code like Pawns, the Inventory Component, and Player Controllers acting as the Controller.</p> <p>Tip</p> <p>While you are welcome to modify all of the UMG widgets inside of the Plugin, it is recommended that you copy them out into your own project.  Plugin Updates may overwrite any changes you make.</p>"},{"location":"arcinventory/concepts/ui/#ui-data","title":"UI Data","text":"<p>Item Specific UI Data is stored in a blueprintable <code>UIData</code> instanced object inside of the Item Definition or Item Generator.  Both ItemDef and ItemGen have this object, as it allows you display item generators to the user if your game design requires it.</p> <p>UI Data objects can be easily extended in blueprint to add new properties.  It is common to create multiple types of UIData structures for different items.  UMG widgets can access this object and cast to whichever child class is needed to display it.</p> <p>Warning</p> <p>UI Data is not replicated!  If there are specific properties you wish to replicate to display on the UI, it must be replicated in the Item Stack.</p>"},{"location":"arcinventory/concepts/ui/#item-slot-widget","title":"Item Slot Widget","text":"<p>Item Slot Widgets are the primary method for showing the contents of an item slot.  Item Slot Widgets can query for a given slot based on some query, or can be given a SlotRef directly on construction.  Once bound to an item slot, it will display the contents of that slot.</p> <p>Info</p> <p>Provided is an example Bag widget, which fills the widget with Item Slot Widgets equal to the number of slots in a bag inventory, and bound to those slots.  It's a good reference for dynamically creating Slot Widgets!</p>"},{"location":"arcinventory/concepts/ui/#item-cards","title":"Item Cards","text":"<p>Items are displayed using an 'Item Card' widget, or a specific UMG subclass that contains a reference to an item and displays the information within that card.  By default, there are two types of Item Cards, Small and Large.  Small Item Cards are generally a 32x32 image displaying the item on top of the item slot widget or while dragging and dropping.  Large Item Cards are used to display the item when you mouse over the Item Card, and often contain all of the data.  The Item Cards look into the Item's UI Data for textures and names to use. </p> <p>It is up to the implementer to create their own displays, but some examples are provided in the plugin.  </p>"},{"location":"arcinventory/concepts/ui/#drag-and-drop","title":"Drag and Drop","text":"<p>Item Slot Widgets implement drag and drop behaviors, allowing for easy swapping of item slots by simply dragging the item to another slot widget.  This is done by way of calling an ability on the player by a tag as defined in the project settings.  </p> <p>Tip</p> <p>More information is located in the Manipulating Items tutorial!</p>"},{"location":"arcinventory/integrations/moveit/","title":"MoveIt","text":""},{"location":"arcinventory/integrations/moveit/#what-is-moveit","title":"What Is MoveIt?","text":"<p>MoveIt's Marketplace Description</p> <p>MoveIt! is a semi-procedural locomotion system for Unreal Engine 4 featuring full network replication and easy integration. MoveIt! is aimed at all game types, and works especially well with shooters or melee games that are camera-facing.</p> <p>MoveIt! was spawned from a need for high quality, replicated, and performance focused locomotion that simply did not exist. Very clean, easy to use, well documented and works flawlessly in multiplayer while being built on top of a solid foundation allowing for on-going updates and improvements.</p> <p>MoveIt! also utilizes multi-threaded animation which is very rare with marketplace assets, and will allow you to have more characters with better performance!</p> <p>You can acquire it here on the Unreal Marketplace</p>"},{"location":"arcinventory/integrations/moveit/#project-setup","title":"Project Setup","text":"<p>To begin integration, ensure that MoveIt is setup according to their documentation</p> MoveIt 1.x <p>MoveIt Project Setup</p> MoveIt 2.x <p>Documentation is not released yet</p> <p>Warning</p> <p>Ensure that <code>\"MoveIt\"</code> is part of your PublicDependencyModuleNames in your build.cs!</p>"},{"location":"arcinventory/integrations/moveit/#subclassing-itemdef","title":"Subclassing ItemDef","text":"<p>Once we've set up MoveIt, it's time to integrate arc inventory.</p> <p>First, we are going to create a new Subclass of <code>UArcItemDefinition_Active</code>, and add MoveIt's <code>FMIWeapon</code> structure to it</p> <pre><code>UCLASS()\nclass MYGAME_API UMyItemDefinition_Active : public UArcItemDefinition_Active\n{\n    GENERATED_BODY()\npublic:\n\n    UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = \"Attachment\")\n    FMIWeapon WeaponAttachData;\n};\n</code></pre> <p>Compile that, and then launch your editor.  </p> <p>From there, Create a new Blueprint based on <code>UMyItemDefinition_Active</code>, name it <code>BP_MyMoveItItem</code>.  Save this item</p> <p>Tip</p> <p>If you already have an item, you can simply reparent already existing items to this new class</p> <p>From there, configure the <code>Weapon Attach Data</code> field, but leave <code>Weapon Mesh</code> as None.</p> <p>Note</p> <p>MoveIt ships with a Rifle and Pistol animation pose and offset.  Your own custom animations can be placed here, but that is beyond the scope of this tutorial.</p> <p>For more information, refer to the MoveIt Weapon Documentation</p>"},{"location":"arcinventory/integrations/moveit/#setting-up-the-player","title":"Setting Up the Player","text":"<p>In your Character blueprint, create a new Variable named <code>WeaponInfo</code> of type <code>MI Weapon</code>.  This will be where we store the Weapon Info struct from the item.</p> <p>Also, in your character blueprint, Create a new Skeletal Mesh component as a child of Mesh.  Name it <code>Held Item Mesh</code>.  </p> <p>From there, Select your Inventory Component, and scroll to the Events section.  Press the big green button for \"On Item Active\" and \"On Item Inactive\" to bind a blueprint function to these events.</p> <p>In your OnItemActive handler, cast the <code>Item Stack</code> to <code>MyItemDefinition_Active</code>.  Call <code>Get Class Defaults</code> on the resulting struct to grab the Weapon Attach Data.  Set your Character's <code>Weapon Info</code> variable to be that attach data.  </p> <p></p> <p>Also, in this handler, grab the Held Item Mesh from the class (you may have to select the Get Class Defaults pin and delect it in the details editor) and assign it to your HeldItemMesh component's mesh.</p> <p>in the OnItemInactive handler, simply set MI Weapon to be an empty struct, and set your HeldItemMesh's mesh to empty.</p> <p>Finally, in Functions, hit Override and override the function <code>Get Weapon Anim Info</code>.  In there, drag in a getter for your <code>WeaponInfo</code> struct and right click on it, select 'Split Struct Pin'. Drag off from <code>Weapon Info Weapon Pose</code> an Is Valid check.  If it is not valid, simply return an empty struct.  If it is valid, create a new Return node, and right click on that and Split Struct Pin.  Connect all the pins from your class's weapon struct to the return node's pins, except the <code>Return Value Weapon Mesh</code> which should be linked to your <code>Held Item Mesh</code> component.</p> <p></p>"},{"location":"arcinventory/integrations/moveit/#conclusion","title":"Conclusion","text":"<p>That is it!  MoveIt will now properly animate your character to hold the weapon.</p>"},{"location":"arcinventory/tutorials/containers/","title":"Maniuplating Items inside and outside of your Inventory","text":""},{"location":"arcinventory/tutorials/containers/#swapping-slots","title":"Swapping Slots","text":"<p>The Primary method to swap items is to activate the built in Swap Item Slots Ability.  This is stored in the ArcInventoryContent folder in your content browser.  </p> <p>Note</p> <p>If you do not see it, you will need to click the little eyeball and enable \"Show Plugin Content\" and \"Show Engine Content\"</p> <p>Swapping Items is done by setting, on the client, the <code>SwapToSlot</code> and <code>SwapFromSlot</code> on the Inventory component, and then activating the ability.  The Ability will then synchronize the FromSlot and ToSlot to the server, and execute the <code>SwapItemSlots</code> function.  This is predicted on the local client, so feedback is instant.</p> <p>Note</p> <p>The default Item Slot Widget will try to activate abilities by the Swap Item Slot tag in the Project settings.  If you cannot get item swapping working, check that your character has that ability, and that tag is set in the project files, and that tag is part of the Ability Tags in the Swap Item Slot ability.  </p> <p>If you are writing your own UI, it is recommended that you set the <code>SwapToSlot</code> and <code>SwapFromSlot</code> properties and then call the ability.  </p> <p>Tip</p> <p>It is recommended that you copy the Swap Item Slots ability out of the plugin and into your project.  Games may need more rules around swapping item slots, and modifying an asset in the plugins folder can be dangerous.</p> <p>You can also create your own SwapItemSlots ability if you want to use your own replication method</p>"},{"location":"arcinventory/tutorials/containers/#dropping-items","title":"Dropping Items","text":"<p>Included in the plugin is an ability that will drop an item from an item slot.  This Ability handles all dropping of items by replicating the slot to the server, removing the item from the inventory in that slot, and then spawning a \"World Item\" with that stack as part of it (See Item Stack Concepts for more information).</p> <p>The removal of items from your inventory is not predicted.  In high latency environments, you will have a delay between the user attempting to drop the item, and the item being removed from the inventory and spawning in the world.   </p> <p>Note</p> <p>The Default Item Slot Widget will attempt to drop an item into the world if the drag and drop operation ends without an underlying Item Slot Widget.  This is done by activating any ability on the owning character with the <code>Item Slot Drop Ability Tags</code>.  As with Swapping, ensure that your character has this ability, that tag is set in the project settings, and the ability has it in it's Ability Tags.</p> <p>If you are writing your own UI, it's recommended that you set the <code>PendingItemDrop</code> property in Inventory and call the ability by tag.  </p> <p>Tip</p> <p>As with the Swap Item Slots ability, it is recommended that you copy this ability out of the plugin and into your project.</p> <p>Also as with the Swap Item Slots ability, you can create your own if you need to.</p>"},{"location":"arcinventory/tutorials/containers/#pick-up-an-item","title":"Pick up an item","text":"<p>Picking Up an item is not provided by default in Arc Inventory</p> <p>There are many methods to achieve this, but I will do a simple one for this tutorial that is not predicted.</p> <p>In your character blueprint, Bind an event to <code>Input E</code>.  Create another event called <code>TryPickupItem</code>.  Set it to Run On Server, and check the Reliable button.  Call <code>TryPickupItem</code> in the Pressed event from Input E.  </p> <p></p> <p>In TryPickupItem, call <code>Line Trace By Channel</code>.  Set the Start point to be your Camera's world location and the end point to be some point 400 units in front of the camera, using the forward vector from the character's aim angles.  Set your character to be an Ignore actor.  </p> <p></p> <p>Check the results of this line trace.  If we hit a target, break the hit result and grab the actor.  Cast it to Arc <code>Inventory World Stack Actor</code>.  Grab the item stack in it and call <code>Loot Item</code> on our Inventory with that item stack.</p> <p></p> <p>If the item was successfully looted, Destroy the World Stack Actor.  </p> <p>You now have the item in your inventory.</p> <p>Tip</p> <p>This process can be put into an ability, and every part can be predicted, except for the destroying the world stack actor.  </p>"},{"location":"arcinventory/tutorials/containers/#create-a-container","title":"Create A Container","text":"<p>Any Actor can hold an Inventory Component.  Item Stashes or Chests are a good example of an actor that can hold many items.</p>"},{"location":"arcinventory/tutorials/containers/#create-a-container-actor","title":"Create a Container Actor","text":"<p>To Start, Create a new Actor, which we will call <code>BP_ItemChest</code>.  Give that Actor some visuals (a white Cube will suffice) and a Bag Inventory component.  Give the Bag 12 slots.</p> <p>Warning</p> <p>In Multiplayer, ensure that the actor replicates and the inventory component replicates!</p> <p>Place this actor in the world.  This is our stash that will hold our items.  </p>"},{"location":"arcinventory/tutorials/containers/#create-a-view-widget","title":"Create a View Widget","text":"<p>Now, we need to be able to inspect it.  We must create a UMG widget to view this container.  Create a new widget that we'll call <code>WBP_ChestView</code>.  Lay out the widget however you want, but I went with a simple black border.  </p> <p>In the content of the widget, Add in a <code>BP_InventoryBagWidget</code> to your widget.  This widget will display the contents of any Bag Inventory.  </p> <p>Tab over to the Graph for the widget, and create a new variable of type <code>ArcInventoryComponent_Bag</code> and name it <code>Target Bag</code>.  Check <code>Instance Editable</code> and <code>Expose on Spawn</code>.</p> <p>In the Construct node, set the InventoryBagWidget's <code>Bag Inventory</code> property to your newly created variable.  This will target the bag view to look at whichever target we give it.</p> <p></p> <p>Info</p> <p>I also added a \"Close\" button to my widget, that removes the widget from parent.  You may want to control interaction differently.</p>"},{"location":"arcinventory/tutorials/containers/#interaction","title":"Interaction","text":"<p>Next, we need to interact with a chest to view it's contents.  In your player, create a new input button for viewing the widget.  Similar to the Pickup Item, we need to line trace forward to see if we are looking at a chest.</p> <p>Do what you did for line tracing, but this time cast to <code>BP_ItemChest</code></p> <p></p> <p>Once you have the chest, get it's bag inventory component and create a <code>Create Widget</code> node.  Set the class to <code>WBP_Chest View</code>, set the owning player to our player controller, and set the <code>Target Bag</code> to the Chest's bag component.  Add this component to viewport, and then activate the mouse cursor.</p> <p> </p> <p>You should now see the contents of the chest!</p>"},{"location":"arcinventory/tutorials/containers/#transfer-items-between-two-inventories","title":"Transfer Items between Two Inventories","text":"<p>Note</p> <p>This feature requires ArcInventory 1.2.3 or greater.  </p> <p>Simply dragging the item between your inventory and the target inventory should work via Drag and Drop.</p> <p>The Inventory takes any two inventory slots to transfer items to/from.  So long as one of the slotrefs reference a slot in the player's inventory, it will swap between the two inventories.  </p> <p>Caution</p> <p>The default implementation does not check if a player should be transferring items between two inventories.  It is up to you to implement these checks</p>"},{"location":"arcinventory/tutorials/randomitems/","title":"Simple Random Items","text":"<p>For many games, Randomizing stats and abilities on items is an important and fun part of the game.  Games such as Path of Exile, Diablo, Borderlands, Destiny, and many others.  Arc Inventory supports creating randomized items, but setting up the gameplay elements to make it fun is a bit of effort.  This tutorial will cover the basics of how to set up randomized items, weapon/armor slots, granting abilities, and putting items in the correct slots in the UI.  </p> <p>It is expected that you have a basic character setup, as outlined in the GAS Documentation.  Also, a review of the high level concepts is recommended before launching into this tutorial.  This Tutorial will also be in C++ and Blueprint.  </p>"},{"location":"arcinventory/tutorials/randomitems/#part-1-setup-the-inventory","title":"Part 1: Setup the Inventory","text":"<p>In your player pawn, Implement the <code>IArcInventoryInterface</code> from \"Interfaces/ArcInventoryInterface.h\".  Do so like this:</p> <p>YourCharacter.h <pre><code>UCLASS()\nclass YOUR_API AYourCharacter : public ACharacter, public IArcInventoryInterface /* ASC Interfaces here too */\n{\n    //Your character class stuff...\n\nprivate: \n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\n    class UArcInventoryComponent* InventoryComponent;\npublic:\n    static FName InventoryComponentName;\n\n    class UArcInventoryComponent* GetInventoryComponent() const override { return InventoryComponent; }\n};\n</code></pre></p> <p>YourCharacter.cpp <pre><code>    FName AYourCharacter::InventoryComponentName(TEXT(\"InventoryComponent\"));\n\n    AYourCharacter::AYourCharacter(const FObjectInitializer&amp; ObjectInitializer)\n        : Super(ObjectInitializer.SetDefaultSubobjectClass&lt;UArcInventoryComponent_Active&gt;(InventoryComponentName))\n    {\n        InventoryComponent = CreateDefaultSubobject&lt;UArcInventoryComponent&gt;(InventoryComponentName); \n\n    }\n</code></pre></p> <p>Note</p> <p>This setup, with the <code>static FName InventoryComponentName</code> and <code>SetDefaultSubobjectClass</code> allows you to have a bit of a heirarchy for your character classes.  For example, you can have a base class that uses a basic inventory component and a 'PlayerCharacter' subclass that has an Active inventory component.  It is up to you if you want to go this route.</p> <p>Next, create a new Blueprint Class that is a child of <code>AYourCharacter</code>, named BP_YourCharacter.  Verify that you have an Inventory Component on your character.</p>"},{"location":"arcinventory/tutorials/randomitems/#attribute-set-setup","title":"Attribute Set Setup","text":"<p>We now need to create some GAS types, an Attribute set and a pair of abilities.  The Attribute Set will be modified by our items, and the abilities will be granted by them.  </p> <p>To get started, lets create an Attribute Set, which we will call AMyAttributeSet.  Lets give it two attributes, Armor and Power, which we will modify by our randomized items.  You will easily be able to create additional attributes for your game, but to keep this tutorial simple we are going to just make two.  </p> <p>In your editor project, go to <code>File</code>, then <code>New C++ Class</code>.  Check \"Show All Classes\", and select <code>Attribute Set</code> as the parent class.  Name it <code>MyAttributeSet</code> and hit Create Class.  If it asks to edit the class, hit yes.</p> <p>From here, we need to add in our C++ code for this attribute set.  For this, we need to write a bit of boilerplate code, which you can find out more about in the GAS Documentation </p> <p><code>MyAttributeSet.h</code> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AttributeSet.h\"\n#include \"MyAttributeSet.generated.h\"\n\nUCLASS()\nclass UMyAttributeSet : public UAttributeSet\n{\n    GENERATED_BODY()\npublic:\n    UMyAttributeSet(const FObjectInitializer&amp; ObjectInitializer);\n\n    virtual void GetLifetimeReplicatedProps(TArray&lt;class FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;\n\n    UPROPERTY(Category = \"Attributes\", EditAnywhere, BlueprintReadOnly, ReplicatedUsing = OnRep_Power)\n    float Power;\n\n    UFUNCTION()\n    virtual void OnRep_Power(float PreviousPower);\n\n    UPROPERTY(Category = \"Attributes\", EditAnywhere, BlueprintReadOnly, ReplicatedUsing = OnRep_Armor)\n    float Armor;\n    UFUNCTION()\n    virtual void OnRep_Armor(float PreviousArmor);\n\n};\n</code></pre></p> <p><code>MyAttributeSet.cpp</code> <pre><code>#include \"MyAttributeSet.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"AbilitySystemComponent.h\"\n\nUMyAttributeSet::UMyAttributeSet(const FObjectInitializer&amp; ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n    Armor = 30;\n    Power = 100;\n}\n\nvoid UMyAttributeSet::GetLifetimeReplicatedProps(TArray&lt;class FLifetimeProperty&gt;&amp; OutLifetimeProps) const\n{\n    Super::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Power, COND_None, REPNOTIFY_Always);\n    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Armor, COND_None, REPNOTIFY_Always);\n}\n\nvoid UMyAttributeSet::OnRep_Power(float PreviousPower)\n{\n    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Power, PreviousPower);\n}\n\nvoid UMyAttributeSet::OnRep_Armor(float PreviousArmor)\n{\n    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Armor, PreviousArmor);\n}\n</code></pre></p> <p>Now that we've created this attribute set, let's add it to our character's Ability System Component.  In our <code>BP_YourCharacter</code>, access the Ability System Component.  Find the <code>Default Starting Data</code> property, and an add an element to that array.  In the Attributes drop down, select our Attribute Set we just created.  Leave Default Starting Table blank.  </p>"},{"location":"arcinventory/tutorials/randomitems/#simple-ability-setup","title":"Simple Ability Setup","text":"<p>From there, we need a simple ability. For this tutorial, we are just going to create a simple ability that prints out our attributes.  This ability can do whatever we want, but creating gameplay mechanics is a bit outside the scope of this tutorial.  </p> <p>In your content browser, right click, select <code>Gameplay</code> and chose <code>New Gameplay Ability Blueprint</code>.  Select <code>Gameplay Ability</code> from the Parent Classes dialog, and name this ability <code>BP_PrintAttributes_GPA</code>.</p> <p>This ability will be simple.  We are going to get the value of the <code>Armor</code> and <code>Power</code> attributes, and then when we activate our ability it will print the values to the screen.  </p> <p></p> <p>Once we have this ability set up, save it and compile.  </p>"},{"location":"arcinventory/tutorials/randomitems/#randomized-items","title":"Randomized Items","text":"<p>Arc Inventory was originally designed to support randomized items, and accomplishes this through the use of Sub Item Stacks on a given item, and an Item Generator to produce the Item Stack.  </p> <p>In this tutorial, we are going to take advantage of some of the example randomization code provided in the plugin, but we will go into some detail about the structure and how to create your own classes or modify them for your game.  </p> <p>To create a randomized item, we need to have an Item Generator that can support randomization.  For most games, Item Generation produces a rather simple item stack, but for randomization, we need to produce not just an 'base' item stack for the item, we need to also create and attach the randomized properties for the item as well.  In Arc Inventory, we have created a \"Simple Random\" item generator that uses a weight-based randomization algorithm to select the randomized properties to give to an item.  </p> <p>However, we are going to create our own simple randomizer that will select one random property from a list and add it to our item stack as a perk.  </p> <p>So, lets get started creating a Item Generator.  Just like the attribute set, let's create a new C++ class for <code>MyItemGenerator</code>.  In the Create New C++ Class dialog, view all classes and select <code>ArcItemGenerator</code> as the base class.  </p> <p>In the Header, we need to override the <code>GenerateItemStack_Implementation</code> function, the base item definition, and create an array of attribute modifiers.  We will use the Arc Inventory provided <code>FArcPerkModifierData</code> type, which allows us to select and modify a gameplay attribute.  The Item Generator will select a random Modifier and add it to the the item we are creating. </p> <p><code>MyItemGenerator.h</code></p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Generators/ArcItemGenerator.h\"\n#include \"Perks/ArcItemPerkTypes.h\"\n#include \"MyItemGenerator.generated.h\"\n\n/**\n * \n */\nUCLASS()\nclass ARCINVENTORYEXAMPLE_API UMyItemGenerator : public UArcItemGenerator\n{\n    GENERATED_BODY()\npublic:\n\n    virtual UArcItemStack* GenerateItemStack_Implementation(const FArcItemGeneratorContext&amp; Context) override;\n\n    //The base item definition that we will be randomizing\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Definition\")\n    TSubclassOf&lt;UArcItemDefinition_New&gt; ItemDefinition;\n\n    UPROPERTY(EditDefaultsOnly, Category=\"Randomization\")\n    TArray&lt;FArcPerkModifierData&gt; PossibleModifiers;\n\n};\n</code></pre> <p>Let's implement GenerateItemStack_Implementation now.  </p> <p>The first thing we want to do is generate the base item as normal.  To do that, we simply need to call <code>CreateNewItemStack</code> with the Item Definition we are creating.</p> <pre><code>UArcItemStack* UMyItemGenerator::GenerateItemStack_Implementation(const FArcItemGeneratorContext&amp; Context)\n{\n    UArcItemStack* BaseItem = CreateNewItemStack(ItemDefinition, nullptr);\n\n    //Randomize the Item\n\n    return BaseItem;\n}\n</code></pre> <p>Note</p> <p>We aren't using Rarities in this tutorial, so the second parameter of CreateNewItemStack will always be nullptr.</p> <p>Now, we need to randomize the item.  Again, for this tutorial, we are just going to select one randomization and apply it to our item here.  Let's select a random element from the randomization array, and create a new item from it.  We will be using the built in 'Perk' item stacks.  </p> <pre><code>UArcItemStack* UMyItemGenerator::GenerateItemStack_Implementation(const FArcItemGeneratorContext&amp; Context)\n{\n    UArcItemStack* BaseItem = CreateNewItemStack(ItemDefinition, nullptr);\n\n    //Select a random perk\n    int32 index = FMath::RandHelper(PossibleModifiers.Num());\n\n    FArcPerkModifierData RandomModifer = PossibleModifiers[index]; //Copy this modifier out of the possibles\n\n    RandomModifer.Value = FMath::RandRange(1, 50); //Create a random value for this modifier\n\n    UClass* PrevISC = ItemStackClass;\n    ItemStackClass = UArcItemStack_Perk::StaticClass();\n\n    if (UArcItemStack_Perk* NewPerk = Cast&lt;UArcItemStack_Perk&gt;(CreateNewItemStack(UArcItemDefinition_Perk::StaticClass(), nullptr)))\n    {   \n        NewPerk-&gt;Modifiers.Add(RandomModifer); //Add the modifier to the perk\n        //Add the random perk to the base item\n        BaseItem-&gt;AddSubItemStack(NewPerk);\n    }\n    ItemStackClass = PrevISC;\n\n    return BaseItem;\n}\n</code></pre> <p>Note</p> <p>Normally, you would have a custom Item Generator for perks here.  Because this is a simple tutorial with only one item generator, we need to set the ItemStackClass before calling CreateNewItemStack.  If you want to use the multiple item generator strategy, you can see it in <code>ArcItemGenerator_SimpleRandom.cpp</code></p> <p>Now, we have an Item Generator that is capable of generating a randomized item.  </p>"},{"location":"arcinventory/tutorials/randomitems/#inventory-setup-and-item-creation","title":"Inventory setup and Item Creation","text":"<p>Note</p> <p>This section is taken from the Simple FPS tutorial.  If you've done that tutorial already, you can skip this part</p>"},{"location":"arcinventory/tutorials/randomitems/#inventory-layout","title":"Inventory Layout","text":"<p>Arc Inventory makes a very clear distinction between underlying data and the visual representation of that data.  This allows for seperation of work for larger teams, but also for quick iteration of doing temp UI to get design down.  </p> <p>We'll start with adding item slots.  Our goal will be to create an inventory layout similar to the screenshot on the marketplace for Arc Inventory.  For that, we have the following:</p> <ul> <li>Primary Weapon</li> <li>Secondary Weapon</li> <li>Head Armor</li> <li>Body Armor</li> <li>Passive Slot 1</li> <li>Passive Slot 2</li> <li>N Bag slots</li> </ul> <p>The Primary Weapon and Secondary Weapon slots can hold Active Items (IE: weapons that can be held in the character's hand), and for the sake of this tutorial, we'll say that only Pistols can go in the Secondary Weapon slot and any active items can go into primary.  Head and Body armor require items that fit directly in that slot, but Passives can hold any passive item except Head and Body armor.  N Bag Slots means that you have any number (lets say 12) slots that can hold any item, but if the item is in that bag slot it does nothing. </p> <p>Open BP_Character and navigate to the Inventory Component on it.  There, you will see 'Bag Slot Count'.  Set that to 12 (Note, you can bind it to a GameplayAttribute, and the bag will resize as that attribute changes).  This gives us N Bag Slots.</p> <p>From there, in the Inventory Layout section, Create 6 array elements.  These will be our custom slots.</p> <p>In slot 0, we want to have a primary weapon.  So, in the Tags, Give the slot the Active item tag and the Equipment tag (Ensure you set these in the Arc Inventory settings in the project settings).  This will denote this slot as both an Active and Equipment slot, and those behaviors will activate when an item is placed into this slot.  We also want to indicate that this is the 'Primary Weapon' slot, so create a new tag <code>Inventory.Slot.PrimaryWeapon</code> and give it to this slot.  </p> <p>In this slot's filter, we want to create Filter Query that accepts <code>ANY(Inventory.ItemType.Weapon)</code>, and check 'Force Single Stack'.  This will cause the Inventory to check if any item attempting to be placed into this slot contains the <code>Inventory.ItemType.Weapon</code> tag, and it will only accept items with 1 stack.  We'll set the items up later.  </p> <p>Secondary Weapon is similar to Primary weapon.  Give it the Active and Equiment tags, and create a tag named <code>Inventory.Slot.SecondaryWeapon</code> and grant it.  In the filter, create a query that checks for the <code>Inventory.ItemType.Weapon.Pistol</code> tag to ensure that only pistols can be placed in this slot.  </p> <p>For Head and Body Armor, we want to set the Tags to be have the Equipment Tag, and a tag for it's name (ie <code>Inventory.Slot.HeadArmor</code>).  In the Filter, Ensure that the query is looking for <code>ANY(Inventory.ItemType.Passive.Head)</code> and Body respectively.  We also want to force single stack.</p> <p>The passive slots are similar, however they do not need unique tags to identify them.  Give them the Equipment Tag, and give them both the <code>Inventory.Slot.Passive</code> tag, and ensure that their filters only allow passive items (perhaps <code>ANY(Inventory.ItemType.Pasive) AND NOT(Inventory.ItemType.Passive.Head OR Inventory.ItemType.Passive.Body)</code>)  Slots do not need unique tags, and since any valid item can be placed in either slot.  If we wish to find specific items later in code, we can query for different information.  </p> <p>With this, the data is set up for this inventory layout.  Now lets create a few items to put into these slots</p>"},{"location":"arcinventory/tutorials/randomitems/#creating-some-items","title":"Creating Some Items","text":""},{"location":"arcinventory/tutorials/randomitems/#weapons","title":"Weapons","text":"<p>Create a new Blueprint Class that inherits from UArcItemDefinition_Active.  Active Item Definitions are item definitions that denote items that can be held in a player's hand.  Active Items can be placed into any slot, but they only can become active if placed in a slot with the Active Item tag, and the player makes that item active (usually through swapping to that item).</p> <p>In the Owned Tags variable, set the containter to have <code>Inventory.ItemType.Weapon.Rifle</code>, and any other tags you wish to describe this weapon.  I have seen setups with 10+ tags to describe each weapon, and there is very little cost to having many tags on a weapon.</p> <p>In Active Item Ability Info, Set up the Active Ability Entry, by giving it an ability and bind it to input.  See GAS Documentation for methods for doing input.  Add any Attribute Sets you want to this item as well, and any tags that are granted to the player.  Anything defined and set up in Active Item Ability Info is only applied to the character when the item is held in the character's hand.  </p> <p>Once you are happy with this item, Duplicate this item and change it's Owned Tag to have <code>Inventory.ItemType.Weapon.Pistol</code>.  This will go in the secondary slot.  </p>"},{"location":"arcinventory/tutorials/randomitems/#equipment","title":"Equipment","text":"<p>Similar to weapons we want to create some new blueprint classes here.  Unlike weapons, we want to create these based on UArcItemDefinition_Equipment.  While Active items inherit from Equipment (and have many of the same properties), by inheriting from Equipment you cannot make these items active if they are in an active item slot, and thus cannot be held in hand.  </p> <p>In our Owned Tags, we want to give our equipment some tags to describe the item.  we created a few tags when we created the item slots, so make sure you use those tags to describe head and body armor.</p> <p>In the Equipped Item Ability Info, give these Head and Body armor pieces an 'Added Gameplay Effects' entry and give them a gameplay effect that is applied to the character when these items are placed into a slot with the Equipment tag.  This is done automatically.  </p>"},{"location":"arcinventory/tutorials/randomitems/#generating-items","title":"Generating Items","text":"<p>Now that we have some items and an item generator for them, now we must put these two parts together to create items.  In the editor, create a new blueprint based on MyItemGenerator.  We will need to create an Item Generator for each type of item we are making, so expect to make a few of these.  For this tutorial though, we will create one and leave the rest as an exercise for the user.  </p> <p>In the first Generator, we will give it the Rifle as our base item type.  We'll also create two modifiers, one for Power and the other for Armor.  </p> <p>In the <code>Item Definition</code> property, set it to your first item Definition.  In the <code>Possible Modifiers</code> property, create two array elements, setting the first to <code>MyAttributeSet.Power</code> and the econd to <code>MyAttributeSet.Armor</code>.  Leave both of them as the <code>Add</code> op and the Value to 0.0 and slot application to an empty query (we will not be using this). </p> <p>Note</p> <p>In the item definition for the item you are using as the base item, ensure that the \"Print Ability\" ability is the active item bound to input.</p> <p>Now, in our character's starting item generators, we will use this item generator to produce an item.  Set the starting item generator to use your this BP_MyRandomGenerator, and when the game starts up you will have a randomized item.  If you activate the print ability, you will see that the properties have been randomly modified by the perk.  </p> <p>Note</p> <p>Consult the example project for how to set up a character with starting item generators.</p> <ul> <li>Item Drops</li> <li>Pickup into inventory</li> </ul>"},{"location":"arcinventory/tutorials/randomitems/#configuring-the-ui","title":"Configuring the UI","text":"<ul> <li>Item Slot Views</li> <li>Item Cards</li> <li>Perk Views</li> </ul>"},{"location":"arcinventory/tutorials/simplefps/","title":"Arc Inventory Tutorial","text":"<p>How to create a simple Active and Equippable Inventory</p>"},{"location":"arcinventory/tutorials/simplefps/#part-0-setup-arc-inventory","title":"Part 0: Setup Arc Inventory","text":"<p>This Tutorial assumes you've setup the inventory plugin and have it working.  It also assumes you have some form of Ability for a weapon.  You can use the FPS shoot ability from the example.</p> <p>This Tutorial assumes you have a Player Pawn and the Ability System is setup for it.  Refer to the GASDocumentation by tranek for tips and strategies to set that up.</p> <p>This Tutorial assumes you are familair with Gameplay Tags and Gameplay Tag Queries.  Please refer to the Unreal Engine Gameplay Tag documentation for more information.</p> <p>For the UI Section of the tutorial, it assumes you are very familiar with UMG.  </p> <p>This Tutorial uses a mix of C++ and Blueprint.  C++ code will be denoted by a C++ code block like so:</p> <pre><code>Code()\n</code></pre> <p>No C++ code is gauranteed to compile or work.  Examples are for illustration of the point.</p> <p>Blueprint will be described (may add images later).</p> <p>Note</p> <p>Ensure that in the Arc Inventory Settings in the Project Settings, appropriate tags are set for the Bag Slot, Equipment Slot, and Active slot. </p>"},{"location":"arcinventory/tutorials/simplefps/#part-1-setup-the-inventory","title":"Part 1: Setup the Inventory","text":"<p>In your player pawn, Implement the <code>IArcInventoryInterface</code> from \"Interfaces/ArcInventoryInterface.h\".  Do so like this:</p> <p>YourCharacter.h <pre><code>UCLASS()\nclass YOUR_API AYourCharacter : public ACharacter, public IArcInventoryInterface /* ASC Interfaces here too */\n{\n    //Your character class stuff...\n\nprivate: \n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\n    class UArcInventoryComponent* InventoryComponent;\npublic:\n    static FName InventoryComponentName;\n\n    class UArcInventoryComponent* GetInventoryComponent() const override { return InventoryComponent; }\n};\n</code></pre></p> <p>YourCharacter.cpp <pre><code>    FName AYourCharacter::InventoryComponentName(TEXT(\"InventoryComponent\"));\n\n    AYourCharacter::AYourCharacter(const FObjectInitializer&amp; ObjectInitializer)\n        : Super(ObjectInitializer.SetDefaultSubobjectClass&lt;UArcInventoryComponent_Active&gt;(InventoryComponentName))\n    {\n        InventoryComponent = CreateDefaultSubobject&lt;UArcInventoryComponent&gt;(InventoryComponentName); \n\n    }\n</code></pre></p> <p>Note</p> <p>This setup, with the <code>static FName InventoryComponentName</code> and <code>SetDefaultSubobjectClass</code> allows you to have a bit of a heirarchy for your character classes.  For example, you can have a base class that uses a basic inventory component and a 'PlayerCharacter' subclass that has an Active inventory component.  It is up to you if you want to go this route.</p> <p>Next, create a new Blueprint Class that is a child of <code>AYourCharacter</code>, named BP_YourCharacter.  Verify that you have an Inventory Component on your character.</p>"},{"location":"arcinventory/tutorials/simplefps/#part-2-creating-item-slots","title":"Part 2: Creating Item Slots","text":"<p>Arc Inventory makes a very clear distinction between underlying data and the visual representation of that data.  This allows for seperation of work for larger teams, but also for quick iteration of doing temp UI to get design down.  </p> <p>We'll start with adding item slots.  Our goal will be to create an inventory layout similar to the screenshot on the marketplace for Arc Inventory.  For that, we have the following:</p> <ul> <li>Primary Weapon</li> <li>Secondary Weapon</li> <li>Head Armor</li> <li>Body Armor</li> <li>Passive Slot 1</li> <li>Passive Slot 2</li> <li>N Bag slots</li> </ul> <p>The Primary Weapon and Secondary Weapon slots can hold Active Items (IE: weapons that can be held in the character's hand), and for the sake of this tutorial, we'll say that only Pistols can go in the Secondary Weapon slot and any active items can go into primary.  Head and Body armor require items that fit directly in that slot, but Passives can hold any passive item except Head and Body armor.  N Bag Slots means that you have any number (lets say 12) slots that can hold any item, but if the item is in that bag slot it does nothing. </p> <p>Open BP_YourCharacter and navigate to the Inventory Component on it.  There, you will see 'Bag Slot Count'.  Set that to 12 (Note, you can bind it to a GameplayAttribute, and the bag will resize as that attribute changes).  This gives us N Bag Slots.</p> <p>From there, in the Inventory Layout section, Create 6 array elements.  These will be our custom slots.</p> <p>In slot 0, we want to have a primary weapon.  So, in the Tags, Give the slot the Active item tag and the Equipment tag (Ensure you set these in the Arc Inventory settings in the project settings).  This will denote this slot as both an Active and Equipment slot, and those behaviors will activate when an item is placed into this slot.  We also want to indicate that this is the 'Primary Weapon' slot, so create a new tag <code>Inventory.Slot.PrimaryWeapon</code> and give it to this slot.  </p> <p>In this slot's filter, we want to create Filter Query that accepts <code>ANY(Inventory.ItemType.Weapon)</code>, and check 'Force Single Stack'.  This will cause the Inventory to check if any item attempting to be placed into this slot contains the <code>Inventory.ItemType.Weapon</code> tag, and it will only accept items with 1 stack.  We'll set the items up later.  </p> <p>Secondary Weapon is similar to Primary weapon.  Give it the Active and Equiment tags, and create a tag named <code>Inventory.Slot.SecondaryWeapon</code> and grant it.  In the filter, create a query that checks for the <code>Inventory.ItemType.Weapon.Pistol</code> tag to ensure that only pistols can be placed in this slot.  </p> <p>For Head and Body Armor, we want to set the Tags to be have the Equipment Tag, and a tag for it's name (ie <code>Inventory.Slot.HeadArmor</code>).  In the Filter, Ensure that the query is looking for <code>ANY(Inventory.ItemType.Passive.Head)</code> and Body respectively.  We also want to force single stack.</p> <p>The passive slots are similar, however they do not need unique tags to identify them.  Give them the Equipment Tag, and give them both the <code>Inventory.Slot.Passive</code> tag, and ensure that their filters only allow passive items (perhaps <code>ANY(Inventory.ItemType.Pasive) AND NOT(Inventory.ItemType.Passive.Head OR Inventory.ItemType.Passive.Body)</code>)  Slots do not need unique tags, and since any valid item can be placed in either slot.  If we wish to find specific items later in code, we can query for different information.  </p> <p>With this, the data is set up for this inventory layout.  Now lets create a few items to put into these slots</p>"},{"location":"arcinventory/tutorials/simplefps/#part-3-create-the-items","title":"Part 3: Create the items","text":"<p>Since we already created the slots, we have an idea what kinds of items could possibly exist.  From here, lets create some weapons.  </p>"},{"location":"arcinventory/tutorials/simplefps/#weapons","title":"Weapons","text":"<p>Create a new Blueprint Class that inherits from UArcItemDefinition_Active.  Active Item Definitions are item definitions that denote items that can be held in a player's hand.  Active Items can be placed into any slot, but they only can become active if placed in a slot with the Active Item tag, and the player makes that item active (usually through swapping to that item).</p> <p>In the Owned Tags variable, set the containter to have <code>Inventory.ItemType.Weapon.Rifle</code>, and any other tags you wish to describe this weapon.  I have seen setups with 10+ tags to describe each weapon, and there is very little cost to having many tags on a weapon.</p> <p>In Active Item Ability Info, Set up the Active Ability Entry, by giving it a shoot ability and bind it to input.  See GAS Documentation for methods for doing input.  Add any Attribute Sets you want to this item as well, and any tags that are granted to the player.  Anything defined and set up in Active Item Ability Info is only applied to the character when the item is held in the character's hand.  </p> <p>Once you are happy with this item, Duplicate this item and change it's Owned Tag to have <code>Inventory.ItemType.Weapon.Pistol</code>.  This will go in the secondary slot.  </p>"},{"location":"arcinventory/tutorials/simplefps/#equipment","title":"Equipment","text":"<p>Similar to weapons we want to create some new blueprint classes here.  Unlike weapons, we want to create these based on UArcItemDefinition_Equipment.  While Active items inherit from Equipment (and have many of the same properties), by inheriting from Equipment you cannot make these items active if they are in an active item slot, and thus cannot be held in hand.  </p> <p>In our Owned Tags, we want to give our equipment some tags to describe the item.  we created a few tags when we created the item slots, so make sure you use those tags to describe head and body armor.</p> <p>In the Equipped Item Ability Info, give these Head and Body armor pieces an 'Added Gameplay Effects' entry and give them a gameplay effect that is applied to the character when these items are placed into a slot with the Equipment tag.  This is done automatically.  </p>"},{"location":"arcinventory/tutorials/simplefps/#part-4-ui","title":"Part 4: UI","text":"<p>This will be very light, as UI is a very complex topic and this is a getting started tutorial.  </p> <p>Create a new blueprint widget for your inventory.  Split the widget in half using a Vertical Box, with the top half being a Canvas Panel and the bottom half a <code>BP_InventoryBagWidget</code> (Note: this is in the ArcInventory plugin.  You should duplicate it into your project if you wish to edit it)</p> <p>In the top half, place a number of BP_ItemSlotWidgets into the Canvas Panel equal to the number of unique item slots you have.  In the details panel for each of those ItemSlotWidgets, you will see an 'Item Slot Query' property.  In the Slot Type Query field, fill out th Gameplay Tag Query to query the specific slot for each widget (for example, for one of your slots you may want to query <code>ANY(Inventory.Slot.PrimaryWeapon)</code> to make that ItemSlotWidget show what is in the primary weapon slot).</p> <p>From there, consult the Example Project for how to set up responding to Drag and Drop (it's automatically set up with BP_ItemSlotWidget) and how to represent your item in the UI (also, automatically set up).  </p>"},{"location":"arcteams/","title":"Home","text":"<p>Welcome to the Arc Teams Documentation Portal!</p>"},{"location":"arcteams/#description","title":"Description","text":"<p>Arc Teams is a networked multiplayer solution that allows for the creation of Teams and other segmentation methods for players.</p> <p>Arc Teams was built from the ground up to support networked multiplayer games. It powers multiple games, each with different styles of segmenting players. ArcTeams supports both runtime and design time Team Definitions, allowing you to create any type of Team. </p> <p>Arc Teams also supports a concept of \u201cSub Teams\u201d, which are teams within teams. This can be used to further segment players into Squads, Fireteams, Guilds, Factions, or whatever you need for your game. Arc Teams has a small development footprint and integrates simply into any code base. Simply override a few functions in GameMode and add a component to PlayerState, then it works! </p> <p>Get it on the Unreal Marketplace: Marketplace Page</p>"},{"location":"arcteams/#technical-details","title":"Technical Details","text":"<p>Features:</p> <ul> <li>Create Static or Dynamic Teams at runtime or in editor!</li> <li>Plug and play with any existing design</li> <li>Fully networked </li> <li>Create SubTeams to further segment players</li> <li>Easily associate objects in the game world with teams</li> </ul> <p>Still need help?</p> <p>You can get support in our discord!</p> <p>Discord.gg/PunyHuman</p> <p>Plugin channels:</p> <ul> <li>#plugins-general</li> <li>#plugins-support</li> </ul>"},{"location":"arcteams/debugaids/","title":"Debug Aids","text":"<p>This Page contains all of the console commands and tools for debugging the system and gaining a better understanding of it's functionality.  Debug tools are not intended for normal use and may be unstable, and your milage may vary.  </p> <ul> <li> Console Command: <code>ShowDebug Team</code> Shows a debug overlay, listing all teams, subteams, and players in those teams.  It takes server replicated strings so it is showing the authority state of the teams system </li> </ul>"},{"location":"arcteams/initialsetup/","title":"Initial Setup","text":"<p>Thanks for purchasing Arc Teams!  Once you've downloaded the plugin and enabled it in your project, this is how you start to use it!</p>"},{"location":"arcteams/initialsetup/#configuring-the-plugin","title":"Configuring the Plugin","text":"<p>Once the plugin is installed and enabled, the next step is to add the Gamemode Component to your gamemode.  This component is the driver for the entire system, and is what manages everything.  Let's add one to our Gamemode to enable configuration and start making teams!</p> C++ <p>In your Gamemode class, add the the component to your gamemode and implement the <code>IArcTeamInterface_Gamemode</code></p> <p><code>MyGameMode.h</code> <pre><code>#include \"Interfaces/ArcTeamInterface_Gamemode.h\"\n\nclass UArcTeamComponent_Gamemode;\n\nclass MYGAME_API AMyGameMode: public AGameMode, public IArcTeamInterface_Gamemode\n{\n    GENERATED_BODY()\n\n    private:\n        UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\n        UArcTeamComponent_Gamemode* TeamComponent;\n\n    public:\n        AMyGameMode(const FObjectInitializer&amp; ObjectInitializer);\n\n        virtual UArcTeamComponent_Gamemode* GetTeamComponent() const override\n        {\n            return TeamComponent;\n        }\n\n        virtual AActor* ChoosePlayerStart_Implementation(AController* Player) override;\n\n        virtual bool ShouldSpawnAtStartSpot(AController* Player) override;\n};\n</code></pre></p> <p><code>MyGameMode.cpp</code> <pre><code>AMyGameMode::AMyGameMode()\n: Super()\n{\n    TeamComponent = CreateDefaultSubobject&lt;UArcTeamComponent_Gamemode&gt;(TEXT(\"Team Component\"));\n}\n\nAActor* AMyGameMode::ChoosePlayerStart_Implementation(AController* Player)\n{\n    return ChooseTeamPlayerStart(Player);\n}\n\nbool AMyGameMode::ShouldSpawnAtStartSpot(AController* Player)\n{\n    return Super::ShouldSpawnAtStartSpot(Player) &amp;&amp; GetTeamComponent()-&gt;CanUsePlayerStartForPlayer(Player, Player-&gt;StartSpot.Get());\n}\n</code></pre></p> <p>Once this is made, create a new Blueprint for this team class.</p> <p>Warning</p> <p>Remember to add <code>ArcTeams</code> to your build.cs!</p> Blueprint <p>For Blueprint, Arc Teams contains a base class <code>ArcTeamGamemodeBase</code>.  Simply create a new blueprint from that class or reparent your gamemode to it</p> <p>Note</p> <p>It is currently not possible to add a team gamemode component in blueprint.  This is because some functions need to be overriden in AGameMode and you cannot override them in blueprint.</p> <p>It is highly recommended that you follow the C++ path for this section to set up your gamemode.  </p> <p>Once the component is added, you need to configure the teams in the component.</p> <p>Open your Gamemode blueprint and inspect the Team Component that is part of it.  Within it contains a number of configuration properties for setting up teams.  </p> <p>For now, we are going to modify the <code>Default Teams</code> array to add two teams, a Red Team and a Blue Team.  Add two array elements and se their Instance Tags to <code>Team.Slot.Red</code> and <code>Team.Slot.Blue</code> respectively.  We will return to this to set their TeamDefinitions, but Team Class remain <code>none</code> as we are not changing the underlying Team Instance in this tutorial.</p> <p>Info</p> <p>The Instance Tags property makes use of Unreal Engine's Gameplay tag system.  More information can be found here: Unreal Engine Documentation</p>"},{"location":"arcteams/initialsetup/#creating-team-definitions","title":"Creating Team definitions","text":"<p>In the editor, we need to create a pair of team definitions for Red Team and Blue Team.  Create two blueprints that inherit from <code>ArcTeamDefinition</code>, <code>BP_TeamDef_Red</code> and <code>BP_TeamDef_Blue</code>.  </p> <p>In the Red team blueprint, we will set the Owned Tags property to contain the <code>Team.Side.Red</code> tag (Create it if it doesn't exist) and in the UI Data property, set it's type to <code>Arc Team UIObject Team Definition</code>.  Set it's name to <code>Red</code> and the color to a reddish color.  </p> <p>For Blue Team, do the same, but change the names to Blue and the color to Blue.  </p> <p>Head back to our gamemode, and within the Default Teams array, set the first element's TeamDefinition to Red and the second's to Blue.  </p> <p>Info</p> <p>Team Definitions are a data-only object that provide all the static data for a given team.  For more information, check the Team Definition Concepts page!</p>"},{"location":"arcteams/initialsetup/#putting-players-into-teams","title":"Putting Players Into Teams","text":"<p>Putting players into teams is fairly straightforward, and Arc Teams provides an automatic way to assign players to teams if your game wants to do that.  If, in the Gamemode Component <code>Auto Assign New Players</code> is checked, then when a player joins the game they will be assigned automatically to any team that has <code>Auto Joinable</code> checked in it's team definition.</p> <p>However, if you want players to be manually assigned to a team, you can do so by calling <code>PlayerRequestJoinTeam</code> on the GameMode component with that player's PlayerState component.</p> <p>Tip</p> <p>PlayerState Components are automatically placed on characters.  You can get a player's PlayerState Component easily by calling <code>UArcTeamsBlueprintLibrary::GetPlayerStateComponentFromPlayer</code> in C++ or that same function in Blueprint.  It takes the PlayerController.  </p> <p>It is recommended, for performance reasons, that you manually add the PlayerState Component to your player state object, but ArcTeams will automatically do it for you if you forget or want to get the plugin up in running fast.</p>"},{"location":"arcteams/initialsetup/#conclusion","title":"Conclusion","text":"<p>That's it!  Now you have a working team system!</p>"},{"location":"arcteams/changelog/1.2.1.86/","title":"1.2.1.86","text":""},{"location":"arcteams/changelog/1.2.1.86/#the-initial-marketplace-release","title":"The Initial Marketplace Release","text":"<ul> <li>Initial Marketplace Release</li> </ul>"},{"location":"arcteams/changelog/1.3.0.98/","title":"1.3.0.98","text":""},{"location":"arcteams/changelog/1.3.0.98/#the-one-that-supports-427","title":"The one that supports 4.27","text":"<ul> <li>Removed Win32 support, as UE will no longer support it</li> <li>Fixed a bug where subteams were in the team list when \"include subteams\" was false</li> <li>Fixed not spawning on default spawns after teams change</li> <li>Allow blueprinting of ArcTeamJoinRequirement</li> </ul>"},{"location":"arcteams/concepts/highlevel/","title":"High Level","text":"<p>High level, Arc Teams is a player segmentation system, and a way to tag players into groups and teams.  </p>"},{"location":"arcteams/concepts/highlevel/#project-goals","title":"Project Goals","text":"<p>Arc Teams has a few goals, and they are reflected within the Teams System</p> <ol> <li> Don't assume Game Design Arc Teams does not assume your game design.  It's core structure is a player segmentation system that allows players to be put into different teams, and then allow those teams to operate among themselves and among the players. </li> <li> Let the user Subclass Arc Teams does not implement game design, so design must allow users to subclass as much as possible to add functionality to teams and players within them.  Every part of Teams can be subclassed, functionality extended, and game design can be implemented with ease. </li> <li> The Components do the work Arc Teams introduces a number of components that do the work for the system.  By isolating the implementation details into components, team interaction can grow, be tested, and improve without negative code patterns forming. </li> </ol>"},{"location":"arcteams/concepts/highlevel/#team-components","title":"Team Components","text":"<p>The primary driver of Teams is a collection of components that are placed onto certain Gameplay Framework objects, such as the GameMode, Game State, and Player States.  Each component has a primary function that drives certain parts of the team and segmentation logic.  </p> <p>The GameMode component is the authoirty of the system.  It handles the creation and destruction of all teams, the segmentation of players, and executing the rulesets for players joining and leaving those teams.  </p> <p>The GameState Component is the replication owner for all ArcTeams primitives.  It handles the transfer of teams to all players and provides a common starting point for UI to display information about the teams.</p> <p>The Player State Component handles the association of Player to Team, and the per-player state for the system.</p>"},{"location":"arcteams/concepts/highlevel/#teams","title":"Teams","text":"<p>Teams are a tree-like UObject that is replicated to all players.  Players are associatied with Teams, forming the backbone of the segmentation system.</p> <p>Teams can have any number dependent Teams, known as SubTeams.  Those SubTeams can have further SubTeams, allowing for segmenting players within a given Team.  Teams without a parent Team are known as Primary Teams.</p> <p>Tip</p> <p>Use Subteams to create features such as Squads or Fireteams!</p> <p>Teams have an associated default-object only object known as a Team Definition, that contains static data for that Team.  This data is not replicated, and can be used to store UI information that does not need to be sent to the clients for a Team.  </p>"},{"location":"arcteams/concepts/highlevel/#team-states","title":"Team States","text":"<p>Some data requires a full actor channel to replicate effeciently, so Teams may create Team State actors to handle the replication to clients.  Team States come in two flavors, the Public Team State, and the Private Team State.  Public Team States are replicated to all players in a server, and Private Team States are replicated to only members of that team. </p> <p>Tip</p> <p>Use Public Team States for replicating data such as the Score, Respawns, or other game state that all players must know.  You can use the Private Team State to replicate information only available to a Team, such as Resources, Team Orders, or even collections of team associated objects like buildings.</p>"},{"location":"arcteams/concepts/team/","title":"Teams","text":""},{"location":"arcteams/concepts/team/#teams","title":"Teams","text":"<p>Teams are the primary object segment players, represented by the UArcTeam object.  Teams are a Replicated UObject that are sent to all players through the Game State Component. </p> <p>Teams are extremely thin, small objects, and players have one Primary Team and many SubTeams.  Teams can only be created by the Game Mode Component. </p> <p>By default, each player is assigned to a Primary Team upon joining a server.  A player may only be in one Primary Team, and must leave their Primary Team before joining a new one.  Players may also not have a Primary Team, and are considered Unassigned.  A Spectator Team is also created by default, and any player placed into Spectator by AGameMode is placed into that spectator team. </p> <p>Info</p> <p>The auto assignment behavior can be modified easily by unchecking 'Auto Assign New Players' in the Game Mode Component.</p>"},{"location":"arcteams/concepts/team/#join-requirements","title":"Join Requirements","text":"<p>By Default, Arc Teams does not implement any mechanism to ensure that players should join teams.  To that end, a class, UArcTeamJoinRequirement, exists with an implementable method in C++ or Blueprint to implement rules around joining any team.  </p>"},{"location":"arcteams/concepts/team/#sub-teams","title":"Sub Teams","text":"<p>All Teams (including SubTeams) may have any number of Sub Teams, which are simply UArcTeam objects added to a parent team.  A player may join any SubTeam, so long as the join is approved by that team's Join Requirements.  </p> <p>Subteams are useful for further segmenting players, and are used for features such as Squads, Parties, and similar segmentation within a team.</p> <p>Note</p> <p>By Default, Arc Teams does not require a player be part of of a SubTeam's parent team to join the SubTeam.  Arc Teams does provide a default implementation for a Join Requirement that enforces this state.</p> <p>Subteams can be queried from nearly any accessor for teams.  ArcTeams provides a few methods to do so, including a query by TeamDefinition class, matching GameplayTagQuery, or just collecting all of them.</p>"},{"location":"arcteams/concepts/team/#team-definitions","title":"Team Definitions","text":"<p>Team Definitions are a class, UArcTeamDefinition, that describes static data and UI data for the team.  The Team Definition may be reused across multiple teams, and assists in reducing replication load for the system.  </p> <p>Note</p> <p>Team Definitions cannot be dynamically created, but multiple teams can use the same definition.  </p>"},{"location":"arcteams/concepts/team/#team-states","title":"Team States","text":"<p>To assist with replicating large amounts of team data, Arc Teams provides a pair of actors that are spawned by teams to assist with replication.  </p> <p>Public Team States, <code>AArcPublicTeamState</code> is replicated to every player, and is easily accessed on clients.  Similar to the AGameState class, this is a useful construct for describing team data that everyone in the game can see, such as score, objective progression, and the like.</p> <p>Private Team States, <code>AArcPrivateTeamState</code>, is only replicated to players within that team.  This is a useful construct for replicating private team data like objectives, storing a team's private game objects, or progress toward victory.  </p> <p>Team States are created when a team is created, and destroyed when the team is destroyed.  If no TeamState class is provided in the TeamDefinition, no TeamState is created.  </p> <p>Tip</p> <p>Team States are full actors! Try putting components on them for additional functionality!</p>"},{"location":"arcteams/concepts/teamcomponents/","title":"Team Components","text":""},{"location":"arcteams/concepts/teamcomponents/#game-mode","title":"Game Mode","text":"<p>The Game Mode Component, <code>UArcTeamComponent_Gamemode</code>, is the main controller for Arc Teams.  It must be applied to your GameMode, and two functions must be overriden to provide it functionality.  </p> <p>Info</p> <p>See the Initial Setup page for more information on how to set up your GameMode to use Arc Teams!</p> <p>The GameMode Component is the authority in creating teams and allowing players to join or leave those teams.  The GameMode Component also creates SubTeams and handles allowing players to spawn on team associated start points.  </p>"},{"location":"arcteams/concepts/teamcomponents/#notable-functions-and-properties","title":"Notable Functions and Properties","text":"<ul> <li> <code>CreateTeam</code>/<code>CreateSubTeam</code> These functions create teams for the system.  They are automatically called on game init for teams defined in <code>DefaultTeams</code>, but you can call them directly to create teams dynamically. </li> <li> <code>PlayerRequestJoinTeam</code> This function is the only way for a player to join a team.  This request may fail (so check the return value!) if the JoinRequirements fail the player.   </li> </ul>"},{"location":"arcteams/concepts/teamcomponents/#game-state","title":"Game State","text":"<p>The GameState component is a helper component for replicating teams to the client.  It contains a number of accessors for getting the teams that exist that can be called from the client, as well as callbacks on both the client and server for when teams are added and removed.  </p> <p>Note</p> <p>The Game State Component is automatically added to your game state if it doesn't exist.  It is recommended that you add a GameState Component to your GameState manually, but it is not required. </p>"},{"location":"arcteams/concepts/teamcomponents/#player-state","title":"Player State","text":"<p>The PlayerState Component is the component that holds the association between Player and Team.  It contains accessors for PrimaryTeam and all SubTeams that a player is part of.  It is also the component that contains the events for when Players join and Leave teams, including SubTeams.  </p> <p>Note</p> <p>Player State Components, like the GameState Component, is automatically added to players when they join the game.  It is highly recommened that you manually add this component to your Player State class manually, but it is not required. </p>"},{"location":"notes/","title":"Home","text":"<p>Welcome to the Kunoichi Docs!</p>"},{"location":"notes/#description","title":"Description","text":"<p>Here you can read notes from other games and ideas that can be used for Kunoichi game.</p>"},{"location":"notes/carrion/","title":"Carrion","text":"<ul> <li>destructible enviro, unlockable passages (through abilities active or simple interactables)</li> <li>manipulation of enemies, objects</li> <li>temporary power ups</li> <li>arena of combat</li> <li>unlockable interactables</li> <li>timed puzzles</li> <li>level paths branching</li> <li>long range interactables</li> </ul>"},{"location":"notes/fallen_order/","title":"Star Wars Jedi: Fallen Order","text":"<ul> <li>rope jumping</li> <li>visible interactables for traversing with hotkeys</li> <li>instant run lift to stand</li> <li>free wall climb</li> <li>many platform in various forms</li> <li>recovery state from some modes, events</li> <li>custom actions while climbing</li> <li>sliding down on slope</li> <li>unlocked abilities panel</li> <li>static weather and implications (clothes wetness)</li> <li>higher elevation takedown</li> <li>deflection</li> <li>zip line, traverse on pipe/log (under and above)</li> <li>notes: sideline (divided into parts) story</li> <li>weapon, equipment cosmetics</li> <li>tutorial through exploration</li> <li>wall run!</li> <li>story through interactables (e.g. scanning), items </li> <li>great ominous, uplifting UI sounds and interaction</li> <li>findings, quests, dead enemies scanning gives XP, equipment variants and codex entries (tactical guide!)</li> <li>unique environment elements, moving mechanical parts, large objects</li> <li>fighting with evil corrupted enemies</li> <li>close wall animation</li> <li>interactions, unlockable paths gated by abilities (unlock after certain quests, story events)</li> <li>music atmosphere depending on environment theme</li> <li>scanning world objects gives clues</li> <li>physics based puzzles (platforms, ropes, water)</li> <li>eternal, ancient \"force\"</li> <li>fast moving crushing blocks</li> <li>steep slope animation, movement</li> <li>combo moves</li> <li>arty skill tree made in stone (many UI animation, moving parts), probably 3D widget</li> <li>local wind affect while in air (vertical and horizontal)</li> <li>short map events that unlock abilities</li> <li>strong critical hits after special action</li> <li>meditate, rest map</li> <li>companion</li> <li>unique abilities that affects not only combat but also other game elements (level progression)</li> <li>not many archetypes of enemies but variants with varied gameplay for each</li> <li>outline objects that interactables with special force</li> <li>no levels only skill points and granted abilities (force)</li> <li>special events that gives skill points and force</li> <li>shortcuts unlockable only from one side</li> <li>preview of abilities (backed movies) in skill tree, UI</li> <li>lose only portion of health on critical fall (no death)</li> <li>paths change after interactions with objects</li> <li>finishers, crits on crumble</li> <li>chests, secret special animation</li> <li>findings quantities visible on map level, section</li> <li>same path -&gt; multiple experiences on different game phase</li> <li>companion with abilities (some you can activate directly)</li> <li>environmental traps</li> <li>swimming, also underwater - expanding traversing, secret paths</li> <li>world wap fog of war</li> <li>jumping pads</li> <li>double jump</li> <li>gas poison release on enemy death, poison on hit (even when blocked)</li> <li>companion shows interactables, POI</li> <li>posture meter - when empty can't block and get crit</li> <li>light/energy beam in puzzles</li> <li>lifts, ziplines, slop slide for fast travel</li> <li>random boss encounters at later stages in low threat spots</li> <li>balanced progression: health system, damage, new abilities</li> <li>default FOV 45</li> <li>plot twists (enemy turn into ally)</li> <li>projectile and melee deflection</li> <li>diversity in combat encounters: archetypes mixed in quantity and quality</li> <li>manipulate circuits connections in puzzles</li> </ul>"},{"location":"notes/fez/","title":"FEZ","text":"<ul> <li>towers, vertical level design</li> <li>artifacts, secrets</li> <li>precision platformer</li> <li>level as puzzle - 2D with 3D rotation</li> <li>gates, keys, warp gates, secret shortcuts</li> <li>no combat</li> <li>theme based levels</li> <li>dynamic levels: player position, interactables, movables, time, keys, black holes (anomalies)</li> <li>unique custom puzzles, mission to unlock passage</li> </ul>"},{"location":"notes/gow_ragnaraok/","title":"Gow ragnaraok","text":"<p>s# God of War Ragnarok</p> <ul> <li>grapple hook to elevate and jump down from high ledge</li> <li>empower weapon ability for one attack</li> <li>many settings for gameplay, HUD, camera, subtitles</li> <li>environment switch location with blades</li> <li>loot hidden in the branch path, often requires new extended jump with blades to get through</li> <li>in-game UI tutorial and codex in sync</li> <li>kill mob puzzle dropping loot</li> <li>skills upgrade when used several times</li> <li>one-sided paths</li> <li>blocked progression clearly explained</li> <li>destructible passage puzzles</li> <li>large secret areas of map</li> <li>mechanics, physics, water puzzles</li> <li>large hubs and maze-like levels</li> <li>\"chase\" sequence</li> <li>mobility through abilities</li> <li>no hit weapon damage buildup</li> <li>ricochet projectile puzzle</li> <li>unblockable attacks that need to be interrupted to block damage</li> <li>weather impact game through sandstorm you need to stop</li> <li>map layers unlocked through story reveling new areas</li> <li>triggers (fight, story) on traverse or collect loot</li> <li>environmental traps, enemies</li> <li>multiple stages of boss fights with save after each one</li> <li>tiers for equipment and related crafting resources</li> <li>multiple player characters and  - separated simplified inventory and skill tree</li> <li>talking sword - mimics speech</li> <li>vertical mechanical-puzzles, map divided (not strictly) into vertical levels</li> <li>combat: simple but unique ways to defeat enemy, e.g. guard break</li> <li>climb into hook climb and opposite</li> <li>multiple sockets for different kind of equipment/weapon</li> <li>boring pacing of the game, more complexity without depth comparing to prequel</li> <li>one level changes (day/night) upon player interaction, unlocking new content</li> <li>loot requires more complex interaction like destruction of vessel</li> <li>visual representation of different attack types</li> <li>combo unique with QTE</li> <li>modular enemy shield broken with specific elemental</li> </ul>"},{"location":"notes/gunk/","title":"Gunk","text":"<ul> <li>POI camera focus</li> <li>towers</li> <li>streaming paths between levels</li> <li>moving and growing platforms</li> <li>interaction by shooting</li> <li>wasteland (toxic, corrupted, toxic areas)</li> <li>unlockable platforms</li> <li>gates, keys</li> </ul>"},{"location":"notes/haak/","title":"Haak","text":"<ul> <li>hidden, destroyable walls, visibility switch areas - leads to secret, path or unlocks traversal mode</li> <li>basic mechanics slowly introduced</li> <li>lots of basic traversal at the beginning</li> <li>stop time when aiming</li> <li>ranged interactables</li> <li>souls like enemy respawns (also some pickables), save system and teleport</li> <li>med kits upon killing enemies or pickable</li> <li>lever, button which changes platform movement</li> <li>gold resources which can be used to buy upgrades - gained from enemies or \"chests\"</li> <li>utility gated clearly informed - fluent progression through exploration</li> <li>guided nonlinearity</li> <li>map - with fog, you can place markers</li> <li>password system - once collected stored in a quest log</li> <li>ori: like magnets you can hook to pass through; thrust (down and separate up) ability to break reinforced structure</li> <li>time puzzles with lazers - requires good timing</li> <li>stamina bars for dash - basically cooldown with one bar, upgrade to double, locked cd in air</li> <li>upgrades for attacks also allows to destroy obstacles</li> <li>saving resets also level blockers</li> <li>deflection</li> <li>health regen actors that doesn't reset level</li> <li>closed arenas with enemy waves</li> <li>multi lock gates - keys spread around</li> <li>dash gives unvernability</li> <li>map previews not visited paths near unlocked area</li> <li>input in attacks affects distance traveled</li> <li>timed, running sections</li> <li>clear visual preview of attack type</li> <li>crouch dash - slide, upgrade to continues slide</li> <li>standard dynamic rope</li> <li>vertical wind</li> <li>quite a lot of side mission from NPCs</li> <li>jumping platforms</li> <li>one hit kill enemies</li> <li>skill/utilities have many upgrades you unlock through level progression</li> <li>toxic gas areas with meter (death ono full) - upgrades for reduce toxicy</li> <li>preview for switch effector</li> <li>difficult boss fight - weird difficulty curve, unique but standing out of from usual encounters</li> <li>dark areas</li> <li>constand updagres some of the abilites - hook mostly: speed, distance, damage on retrive</li> <li>teleport to different entries</li> <li>important NPCs not mark on the map - difficult to track quests</li> <li>compass for POI - later in the game</li> <li>lack of names for areas on the map - could be thematicaly or story related</li> <li>multiple entries to large map - need to progress few to unlock path</li> <li>gliding skill with wind acceleration</li> <li>great platforming</li> <li>good story, music, audio</li> </ul>"},{"location":"notes/junky_games/","title":"Junky Games","text":""},{"location":"notes/junky_games/#supraland","title":"Supraland","text":"<ul> <li>simple game, easy to pickup</li> <li>many systems underdeveloped (boring and clunky): combat, exploration, progression - everything oversimplified and dull</li> <li>puzzles, secret are fine but often obscured (lack of vision guidance)</li> </ul>"},{"location":"notes/junky_games/#journey-to-the-savage-planet","title":"Journey to the savage planet","text":"<ul> <li>exploration is tedious, boring - waste of time, gives mostly collectables you can use for upgrades but there is little to explore for real, markers for secrets are wasted potential which could be cool part of the game</li> <li>combat and controls are straight up bad - lag on controller input, enemies are boring</li> </ul>"},{"location":"notes/junky_games/#grime","title":"Grime","text":"<ul> <li>dull combat, similar to dark souls</li> <li>rough and boring traversal</li> </ul>"},{"location":"notes/junky_games/#teslagrad","title":"Teslagrad","text":"<ul> <li>nice art and story at first</li> <li>bad controls, too slow deceleration</li> <li>problem with puzzle physics - imprecise input (floaty output but requires precise output)</li> <li>often boring, unfunny</li> </ul>"},{"location":"notes/rise_tomb_raider/","title":"Rise of the Tomb Raider","text":"<ul> <li>Extreme weather conditions</li> <li>Cutscenes with quick time events (QTE)</li> <li>QTE while traversing</li> <li>Axe free climb</li> <li>Companions</li> <li>Camera centered on target location while traversing</li> <li>Volume modifiers for traversal</li> <li>Dynamic rope combined with axe</li> <li>Steep slide with axe QTE</li> <li>Moving platforms</li> <li>Quick transition between game and cutscene</li> <li>Lot of quick cutscenes while traversing</li> <li>Lens flares</li> <li>Subtitles in parallel for multiple characters</li> <li>Continuous climbing animation between ledges with only directional input, jump input for far ledges</li> <li>Strong highlight for crucial interactables after focus</li> <li>Highlights enemies after focus</li> <li>Progression for interactables (languages)</li> <li>Double jump - additional jump on vertical surface (long suspension on wall) </li> <li>VFXs while traversing e.g. falling rocks</li> <li>Path changing while you traverse</li> <li>Autosave system, at least for fall deaths</li> <li>Recover state</li> <li>Light source in darkness</li> <li>Traps</li> <li>Obstacles, puzzle elements can be destroyed with weapons or sometimes fire</li> <li>Tons of destructibles</li> <li>PP effects, decals, material functions on character: water, heat, dirt</li> <li>Steep slope mode</li> <li>Slomo mode in high action moments</li> <li>Open/close areas mixup</li> <li>Show objective, interactables after input</li> <li>Water puzzles</li> <li>Swinging, physical movement while climbing</li> <li>Fighting with lunatics, cult (Trinity) - shown through readable notes</li> <li>Infinite ammo for base projectile weapon</li> <li>Many turns, change of view</li> <li>Physics puzzles, interactions (water, weight)</li> <li>One timed travel section, anty-MV principle of returning to previous locations (progression related at least)</li> <li>Epic moments after heavy actions</li> <li>Mixed environments by temperature, barren/lush</li> <li>Many vertical surfaces, short tunnels (with traps)</li> <li>Fast travel system with camps</li> <li>Resources, crafting system: weapon upgrades, consumables, empowered ammunition</li> <li>Wind mechanic but mostly baked behavior</li> <li>Slow movement mode (deep snow, wind, heat, injured)</li> <li>Special ledge climb on narrow beam (stone, branch)</li> <li>Ledge grab while falling with montage</li> <li>Ziplines</li> <li>Pull thorough horizontal line</li> <li>Wildlife you can hunt</li> <li>Stealth attacks, OHK (one hit kill)</li> <li>Aerial takedown</li> <li>Challenges giving xp (combat and exploration related)</li> <li>XP depending on kill type (stealth, takedown, headshot)</li> <li>Region, world map stats</li> <li>Optional challenge tombs - not required for main story, can unlock abilities</li> <li>Timings in traversal</li> <li>Swimming, high jumps</li> <li>Enemy changing into ally and opposite</li> <li>Few weapon types but many upgrades</li> <li>Subtle effect pointing POIs</li> <li>Can distract enemies with throwable objects (shows also trajectory)</li> <li>Clearly visible traversable objects</li> <li>AI has awareness of fallen comrades, go into alert mode after that (shown also with scanning)</li> <li>AI doesn't attack so often while player is in action (e.g. stealth kill), only after slight delay</li> <li>Stealth bushes</li> <li>Markers for aggro enemy when camera currently obstructed</li> <li>Only resources, ammo drop from enemies</li> <li>More vertical elements in open areas (towers, mountains, cliffs)</li> <li>Immersive hand placed VFXs (fire, dust, wind/snow blows, water)</li> <li>Shop keepers - weapons; mostly requires microtransactions to buy anything good</li> <li>Break wall to unlock path</li> <li>Aim bow and unlock by pulling rope</li> <li>Weapon upgrades needs pickable parts</li> <li>Bow charge for better accuracy</li> <li>Distinguishable chapters of the game (intro, puzzle, Trinity encounter, tomb, Trinity post, open area, prison break, ...)</li> <li>Resource don't respawn</li> <li>Can build ziplines with rope bridge between posts</li> <li>Explosive bombs</li> <li>Waves of enemy besides static placed ones</li> <li>Race sections mixed with cutscenes</li> <li>Destructibles platforms (ice, rocks)</li> <li>Ability gates</li> <li>Ascending slowly and rides down</li> <li>Bow concentration for higher accuracy</li> <li>Large 3D widget for objectives</li> <li>Combination of different traverse types</li> <li>Falling objects around in collapse sections</li> <li>Dark levels mostly in caves</li> <li>Towers!</li> <li>Crucial allies on the rode but many npcs in camps</li> <li>Many ammo types per weapon (mostly bow)</li> </ul>"},{"location":"notes/steamworld_dig/","title":"Steamworld Dig","text":"<ul> <li>resources for upgrades and level ups - gold and blue balls accuired during exploration</li> <li>utility gates - fall invulnerability, range and down attack weapons, double jump, charged jump</li> <li>subleveles with enviromental puzzles - possible restart with no loss</li> <li>new shops with powerups unlocked with level - spend resources to unlock</li> <li>secret or end level unlockable - utility, lever mechanic that remove energy</li> </ul>"},{"location":"notes/steamworld_dig/#steamworld-dig-2","title":"Steamworld Dig 2","text":"<ul> <li>skills divided into utilies and upgrades (powerups - swapable)</li> <li>enemies gives XP</li> <li>blueprints - unique findins that unlock bonus utily upgrades</li> <li>dart projectile to dig and attack - more water (energy) but more damage</li> <li>water source doesn't deplite</li> <li>izolated levels with puzzles</li> <li>hubs with gates requiring keys, puzzles to solve</li> </ul>"},{"location":"notes/stray/","title":"Stray","text":"<ul> <li>preview of traverse target location</li> <li>chapters have different types of game loops (stealth, companion coop, combat)</li> <li>realistic cat simulation</li> <li>detailed environment</li> <li>companion and relationship</li> <li>puzzles, mostly through interaction and finding not traversing</li> </ul>"},{"location":"notes/uncharted4/","title":"Uncharted 4","text":""},{"location":"notes/uncharted4/#misc","title":"Misc","text":"<ul> <li>puzzles: traverse modes (e.g. jumping, pull, push), levers, water, ring, symbols, movable elements</li> <li>wildlife: bugs, flies, butterflies, animals</li> <li>rivers, waterfalls, mesh markers (POI)</li> <li>mix mechanics!</li> <li>timing buttons mechanic</li> <li>AI companion events (absence of player input)</li> <li>sound indicators for objects, events, actions</li> <li>screen decals (water, dirt)</li> <li>cloth wetness (water, rain)</li> <li>handmaid environment for crucial places</li> <li>mix puzzles, cutscenes, combat</li> <li>divide plot into acts</li> <li>involved chinese, japan mythology</li> <li>screen shakes</li> <li>drop from ledge option to cancel (back to ledge faster)</li> <li>camera specific settings for POI (remove input in some cases), distant objectives</li> <li>companion helps with puzzle</li> <li>slope slide into other modes (e.g. jump)</li> <li>hands lean on walls, tight places</li> <li>different combat paces</li> <li>introduce mechanics consistently throughout the game in specific events, places</li> <li>moving, drag crates: puzzles or unlock path</li> <li>pull rope mechanic</li> <li>hints when stuck</li> <li>swapping puzzles depending on visit order</li> <li>puzzles with light, beams</li> <li>\"in game\" cutscenes for specific interactions</li> <li>high elevated places for traversing in e.g. swamps requiring jumping or beam pole</li> <li>physical interactables</li> <li>strong connection with environment: search for objectives, avoid threats</li> <li>dynamic environment</li> <li>3 main camera distances: close for cutscenes, medium for combat and far for platforming</li> <li>weather events: e.g tornadoes, rain</li> <li>alternate close and open spaces</li> <li>diverse paths branching</li> <li>towers: POI, quest, secrets</li> <li>quick camera for cinematics with unlocked input</li> <li>player is constancy surprised</li> <li>well crafted weather settings that match plot, action</li> <li>cinematics mixed with animations</li> <li>mixed emotions through game (strong, weak, lonely, in company)</li> <li>journal style quest log</li> <li>strong player character emotions</li> <li>large distance POI</li> <li>utopia theme affecting plot, environment</li> <li>plot twists</li> <li>camera movement match current traverse mode</li> <li>musing attenuated according to situation</li> <li>mazelike level design</li> <li>physics based puzzles (water flow, counter weight)</li> <li>enviro - diversity over quality</li> <li>vertical aspect in level design, puzzles</li> <li>humor in plot</li> <li>swirl climbing (constant changing of direction)</li> <li>many UI buttons/interactables in world space, connected to world space object/bone</li> <li>environment traps - explosives, piles</li> <li>pause, skip, replay cinematics</li> <li>face expression</li> <li>player character move speed adjusted for specific areas, moments</li> </ul>"},{"location":"notes/uncharted4/#combat","title":"Combat","text":"<ul> <li>two combat modes: stealth, normal</li> <li>UI attack indicators in world space (3D widget)</li> <li>empowered stealth attack/kill</li> <li>progression through new abilities, getting skilled, slightly better stats</li> <li>enemies are smarter later in game (difficulty increasing)</li> <li>enemies planned action gives hints on what they want to do (voice, animation)</li> <li>\"6th sense\" (tracking of player), advances hear sense not only sight</li> </ul>"},{"location":"notes/uncharted4/#stealth","title":"Stealth","text":"<ul> <li>raycasts to bones for visibility in cone: need more for successful test, different depending on movement mode</li> <li>enemy awareness shown in UI bar</li> <li>pathfinding for blocked sounds ???</li> <li>show enemy status through animation</li> <li>cheating enemy sense when not on screen (50% reduction)</li> <li>awareness curve (steep - predator, flat - peaceful)</li> </ul>"},{"location":"notes/yoku/","title":"Yoku's Island Express","text":"<ul> <li>resource from \"plaing\" pinball - built into environment with lots of variations</li> <li>fast travel unlocked by money</li> <li>closed sections with puzzles</li> <li>utility gated</li> <li>character slingshot </li> <li>tedious and boring platformer segments</li> <li>long trips between objectives, hidden items - often mixed with bugs related to umbigous traverse</li> </ul>"}]}